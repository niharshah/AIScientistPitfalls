<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script>
      // Check if we're running under Live Server
      if (window.location.hostname === '127.0.0.1' || window.location.hostname === 'localhost') {
          let lastModified = '';

          // Check for file changes every second
          setInterval(async () => {
              try {
                  const response = await fetch(window.location.href, { method: 'HEAD' });
                  // get a timestamp that shows when the file was last changed
                  const currentModified = response.headers.get('last-modified');

                  if (lastModified && lastModified !== currentModified) {
                      window.location.reload();
                  }

                  lastModified = currentModified;
              } catch (e) {
                  console.error('Error checking for updates:', e);
              }
          }, 1000);
      }
  </script>
    <script
      id="p5scripttag"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
      integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <script>
      const bgCol = "#FFFFFF";
const accentCol = "#1a439e";

hljs.initHighlightingOnLoad();

// Function to update background color globally
function updateBackgroundColor(color) {
  // Update the JS variable
  window.bgColCurrent = color;

  // Update body background
  document.body.style.backgroundColor = color;

  // Update canvas container background
  const canvasContainer = document.getElementById('canvas-container');
  if (canvasContainer) {
    canvasContainer.style.backgroundColor = color;
  }
}

// Store tree data for each stage
const stageData = {
  Stage_1: null,
  Stage_2: null,
  Stage_3: null,
  Stage_4: null
};

// Keep track of current selected stage
let currentStage = null;
let currentSketch = null;
let availableStages = [];

// Class definitions for nodes and edges
class Node {
  constructor(x, y, id, isRoot = false) {
    this.x = x;
    this.y = y;
    this.id = id;
    this.visible = isRoot; // Only root nodes are visible initially
    this.appearProgress = 0;
    this.popEffect = 0;
    this.selected = false;
    this.isRootNode = isRoot;
  }

  update() {
    if (this.visible) {
      // Handle the main appearance animation
      if (this.appearProgress < 1) {
        this.appearProgress += 0.06;

        // When we reach full size, trigger the pop effect
        if (this.appearProgress >= 1) {
          this.appearProgress = 1; // Cap at 1
          this.popEffect = 1; // Start the pop effect
        }
      }

      // Handle the pop effect animation
      if (this.popEffect > 0) {
        this.popEffect -= 0.15; // Control how quickly it shrinks back
        if (this.popEffect < 0) this.popEffect = 0; // Don't go negative
      }
    }
  }

  startAnimation() {
    this.visible = true;
  }

  color() {
    if (this.selected) {
      return accentCol; // Use the global accent color variable for selected node
    }
    return '#4263eb'; // Default blue color
  }

  render(p5) {
    if (this.visible) {
      const popBonus = this.popEffect * 0.1;
      const nodeScale = p5.map(this.appearProgress, 0, 1, 0, 1) + popBonus;
      const alpha = p5.map(this.appearProgress, 0, 1, 0, 255);

      p5.push();
      p5.translate(this.x, this.y);

      // Shadow effect
      p5.noStroke();
      p5.rectMode(p5.CENTER);

      for (let i = 1; i <= 4; i++) {
        p5.fill(0, 0, 0, alpha * 0.06);
        p5.rect(i, i, 30 * nodeScale, 30 * nodeScale, 10);
      }

      // Main square - use node's color with alpha
      let nodeColor = p5.color(this.color());
      nodeColor.setAlpha(alpha);
      p5.fill(nodeColor);
      p5.rect(0, 0, 30 * nodeScale, 30 * nodeScale, 10);

      // Draw checkmark icon if the node is selected
      if (this.selected && this.appearProgress >= 1) {
        p5.stroke(255);
        p5.strokeWeight(2 * nodeScale);
        p5.noFill();
        // Draw checkmark
        p5.beginShape();
        p5.vertex(-8, 0);
        p5.vertex(-3, 5);
        p5.vertex(8, -6);
        p5.endShape();
      }

      p5.pop();
    }
  }

  isMouseOver(p5) {
    return this.visible &&
           p5.mouseX > this.x - 15 &&
           p5.mouseX < this.x + 15 &&
           p5.mouseY > this.y - 15 &&
           p5.mouseY < this.y + 15;
  }

  // Connect this node to a child node
  child(childNode) {
    // Create an edge from this node to the child
    let isLeft = childNode.x < this.x;
    let isRight = childNode.x > this.x;
    let edge = new Edge(this, childNode, isLeft, isRight);
    return edge;
  }
}

class Edge {
  constructor(parent, child, isLeft, isRight) {
    this.parent = parent;
    this.child = child;
    this.isLeft = isLeft;
    this.isRight = isRight;
    this.progress = 0;

    // Calculate the midpoint where branching occurs
    this.midY = parent.y + (child.y - parent.y) * 0.6;

    // Use the actual child x-coordinate
    // This ensures the edge will connect directly to the child node
    this.branchX = child.x;
  }

  update() {
    if (this.parent.visible && this.progress < 1) {
      this.progress += 0.01; // Adjust animation speed
    }
    if (this.progress >= 1) {
      this.child.visible = true;
    }
  }

  color() {
    return this.child.color();
  }

  render(p5) {
    if (!this.parent.visible) return;

    // Calculate path lengths
    const verticalDist1 = this.midY - this.parent.y;
    const horizontalDist = Math.abs(this.branchX - this.parent.x);
    const verticalDist2 = this.child.y - this.midY;
    const totalLength = verticalDist1 + horizontalDist + verticalDist2;

    // Calculate how much of each segment to draw
    const currentLength = totalLength * this.progress;

    p5.stroke(180, 190, 205);
    p5.strokeWeight(1.5);
    p5.noFill();

    // Always draw the first vertical segment from parent
    if (currentLength > 0) {
      const firstSegmentLength = Math.min(currentLength, verticalDist1);
      const currentMidY = p5.lerp(this.parent.y, this.midY, firstSegmentLength / verticalDist1);
      p5.line(this.parent.x, this.parent.y, this.parent.x, currentMidY);
    }

    if (currentLength > verticalDist1) {
      // Draw second segment (horizontal)
      const secondSegmentLength = Math.min(currentLength - verticalDist1, horizontalDist);
      const currentBranchX = p5.lerp(this.parent.x, this.branchX, secondSegmentLength / horizontalDist);
      p5.line(this.parent.x, this.midY, currentBranchX, this.midY);

      if (currentLength > verticalDist1 + horizontalDist) {
        // Draw third segment (vertical to child)
        const thirdSegmentLength = currentLength - verticalDist1 - horizontalDist;
        const currentChildY = p5.lerp(this.midY, this.child.y, thirdSegmentLength / verticalDist2);
        p5.line(this.branchX, this.midY, this.branchX, currentChildY);
      }
    }
  }
}

// Create a modified sketch for each stage
function createTreeSketch(stageId) {
  return function(p5) {
    let nodes = [];
    let edges = [];
    let treeData = stageData[stageId];

    p5.setup = function() {
      const canvas = p5.createCanvas(p5.windowWidth * 0.4, p5.windowHeight);
      canvas.parent('canvas-container');
      p5.smooth();
      p5.frameRate(60);

      if (treeData) {
        createTreeFromData(treeData);
      }
    };

    p5.windowResized = function() {
      p5.resizeCanvas(p5.windowWidth * 0.4, p5.windowHeight);
    };

    function createTreeFromData(data) {
      // Clear existing nodes and edges
      nodes = [];
      edges = [];

      // Add defensive checks to prevent errors
      if (!data || !data.layout || !Array.isArray(data.layout) || !data.edges || !Array.isArray(data.edges)) {
        console.error("Invalid tree data format:", data);
        return; // Exit if data structure is invalid
      }

      // Find all parent nodes in edges
      const parentNodes = new Set();
      for (const [parentId, childId] of data.edges) {
        parentNodes.add(parentId);
      }

      // Create nodes
      for (let i = 0; i < data.layout.length; i++) {
        const [nx, ny] = data.layout[i];
        // A node is a root if it's a parent and not a child in any edge
        const isRoot = parentNodes.has(i) && data.edges.every(edge => edge[1] !== i);

        const node = new Node(
          nx * p5.width * 0.8 + p5.width * 0.1,
          ny * p5.height * 0.8 + p5.height * 0.1,
          i,
          isRoot
        );
        nodes.push(node);
      }

      // If no root was found, make the first parent node visible
      if (!nodes.some(node => node.visible) && parentNodes.size > 0) {
        // Get the first parent node
        const firstParentId = [...parentNodes][0];
        if (nodes[firstParentId]) {
          nodes[firstParentId].visible = true;
        }
      }

      // Create edges
      for (const [parentId, childId] of data.edges) {
        const parent = nodes[parentId];
        const child = nodes[childId];
        if (parent && child) { // Verify both nodes exist
          const isLeft = child.x < parent.x;
          const isRight = child.x > parent.x;
          edges.push(new Edge(parent, child, isLeft, isRight));
        }
      }

      // Select the first node by default
      if (nodes.length > 0) {
        nodes[0].selected = true;
        updateNodeInfo(0);
      }
    }

    p5.draw = function() {
      // Use the global background color if available, otherwise use the default bgCol
      const currentBgColor = window.bgColCurrent || bgCol;
      p5.background(currentBgColor);

      // Update and render edges
      for (const edge of edges) {
        edge.update();
        edge.render(p5);
      }

      // Update and render nodes
      for (const node of nodes) {
        node.update();
        node.render(p5);
      }

      // Handle mouse hover
      p5.cursor(p5.ARROW);
      for (const node of nodes) {
        if (node.isMouseOver(p5)) {
          p5.cursor(p5.HAND);
        }
      }
    };

    p5.mousePressed = function() {
      // Check if any node was clicked
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].visible && nodes[i].isMouseOver(p5)) {
          // Deselect all nodes
          nodes.forEach(n => n.selected = false);
          // Select the clicked node
          nodes[i].selected = true;
          // Update the right panel with node info
          updateNodeInfo(i);
          break;
        }
      }
    };

    function updateNodeInfo(nodeIndex) {
      if (treeData) {
        setNodeInfo(
          treeData.code[nodeIndex],
          treeData.plan[nodeIndex],
          treeData.plot_code?.[nodeIndex],
          treeData.plot_plan?.[nodeIndex],
          treeData.metrics?.[nodeIndex],
          treeData.exc_type?.[nodeIndex] || '',
          treeData.exc_info?.[nodeIndex]?.args?.[0] || '',
          treeData.exc_stack?.[nodeIndex] || [],
          treeData.plots?.[nodeIndex] || [],
          treeData.plot_analyses?.[nodeIndex] || [],
          treeData.vlm_feedback_summary?.[nodeIndex] || '',
          treeData.datasets_successfully_tested?.[nodeIndex] || [],
          treeData.exec_time_feedback?.[nodeIndex] || '',
          treeData.exec_time?.[nodeIndex] || ''
        );
      }
    }
  };
}

// Start a new p5 sketch for the given stage
function startSketch(stageId) {
  if (currentSketch) {
    currentSketch.remove();
  }

  if (stageData[stageId]) {
    currentSketch = new p5(createTreeSketch(stageId));

    // Update stage info
    const stageNumber = stageId.split('_')[1];
    let stageDesc = '';
    switch(stageId) {
      case 'Stage_1': stageDesc = 'Preliminary Investigation'; break;
      case 'Stage_2': stageDesc = 'Baseline Tuning'; break;
      case 'Stage_3': stageDesc = 'Research Agenda Execution'; break;
      case 'Stage_4': stageDesc = 'Ablation Studies'; break;
    }

    document.getElementById('stage-info').innerHTML =
      `<strong>Current Stage: ${stageNumber} - ${stageDesc}</strong>`;
  }
}

// Handle tab selection
function selectStage(stageId) {
  if (!stageData[stageId] || !availableStages.includes(stageId)) {
    return; // Don't allow selection of unavailable stages
  }

  // Update active tab styles
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelector(`.tab[data-stage="${stageId}"]`).classList.add('active');

  // Start the new sketch
  currentStage = stageId;
  startSketch(stageId);
}

// Function to load the tree data for all stages
async function loadAllStageData(baseTreeData) {
  console.log("Loading stage data with base data:", baseTreeData);

  // The base tree data is for the current stage
  const currentStageId = baseTreeData.current_stage || 'Stage_1';

  // Ensure base tree data is valid and has required properties
  if (baseTreeData && baseTreeData.layout && baseTreeData.edges) {
    stageData[currentStageId] = baseTreeData;
    availableStages.push(currentStageId);
    console.log(`Added current stage ${currentStageId} to available stages`);
  } else {
    console.warn(`Current stage ${currentStageId} data is invalid:`, baseTreeData);
  }

  // Use relative path to load other stage trees
  const logDirPath = baseTreeData.log_dir_path || '.';
  console.log("Log directory path:", logDirPath);

  // Load data for each stage if available
  const stageNames = ['Stage_1', 'Stage_2', 'Stage_3', 'Stage_4'];
  const stageNames2actualNames = {
    'Stage_1': 'stage_1_initial_implementation_1_preliminary',
    'Stage_2': 'stage_2_baseline_tuning_1_first_attempt',
    'Stage_3': 'stage_3_creative_research_1_first_attempt',
    'Stage_4': 'stage_4_ablation_studies_1_first_attempt'
    }

  for (const stage of stageNames) {

    if (baseTreeData.completed_stages && baseTreeData.completed_stages.includes(stage)) {
      try {
        console.log(`Attempting to load data for ${stage} from ${logDirPath}/${stageNames2actualNames[stage]}/tree_data.json`);
        const response = await fetch(`${logDirPath}/${stageNames2actualNames[stage]}/tree_data.json`);

        if (response.ok) {
          const data = await response.json();

          // Validate the loaded data
          if (data && data.layout && data.edges) {
            stageData[stage] = data;
            availableStages.push(stage);
            console.log(`Successfully loaded and validated data for ${stage}`);
          } else {
            console.warn(`Loaded data for ${stage} is invalid:`, data);
          }
        } else {
          console.warn(`Failed to load data for ${stage} - HTTP status ${response.status}`);
        }
      } catch (error) {
        console.error(`Error loading data for ${stage}:`, error);
      }
    } else {
      console.log(`Skipping stage ${stage} - not in completed stages list:`, baseTreeData.completed_stages);
    }
  }

  // Update tab visibility based on available stages
  updateTabVisibility();

  // Start with the first available stage
  if (availableStages.length > 0) {
    selectStage(availableStages[0]);
  } else {
    console.warn("No stages available to display");
    // Display a message in the canvas area
    document.getElementById('canvas-container').innerHTML =
      '<div style="padding: 20px; color: #333; text-align: center;"><h3>No valid tree data available to display</h3></div>';
  }
}

// Update tab visibility based on available stages
function updateTabVisibility() {
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(tab => {
    const stageId = tab.getAttribute('data-stage');
    if (availableStages.includes(stageId)) {
      tab.classList.remove('disabled');
    } else {
      tab.classList.add('disabled');
    }
  });
}

// Utility function to set the node info in the right panel
const setNodeInfo = (code, plan, plot_code, plot_plan, metrics = null, exc_type = '', exc_info = '',
    exc_stack = [], plots = [], plot_analyses = [], vlm_feedback_summary = '',
    datasets_successfully_tested = [], exec_time_feedback = '', exec_time = '') => {
  const codeElm = document.getElementById("code");
  if (codeElm) {
    if (code) {
      codeElm.innerHTML = hljs.highlight(code, { language: "python" }).value;
    } else {
      codeElm.innerHTML = '<p>No code available</p>';
    }
  }

  const planElm = document.getElementById("plan");
  if (planElm) {
    if (plan) {
      planElm.innerHTML = hljs.highlight(plan, { language: "plaintext" }).value;
    } else {
      planElm.innerHTML = '<p>No plan available</p>';
    }
  }

  const plot_codeElm = document.getElementById("plot_code");
  if (plot_codeElm) {
    if (plot_code) {
      plot_codeElm.innerHTML = hljs.highlight(plot_code, { language: "python" }).value;
    } else {
      plot_codeElm.innerHTML = '<p>No plot code available</p>';
    }
  }

  const plot_planElm = document.getElementById("plot_plan");
  if (plot_planElm) {
    if (plot_plan) {
      plot_planElm.innerHTML = hljs.highlight(plot_plan, { language: "plaintext" }).value;
    } else {
      plot_planElm.innerHTML = '<p>No plot plan available</p>';
    }
  }

  const metricsElm = document.getElementById("metrics");
  if (metricsElm) {
      let metricsContent = `<h3>Metrics:</h3>`;
      if (metrics && metrics.metric_names) {
          for (const metric of metrics.metric_names) {
              metricsContent += `<div class="metric-group">`;
              metricsContent += `<h4>${metric.metric_name}</h4>`;
              metricsContent += `<p><strong>Description:</strong> ${metric.description || 'N/A'}</p>`;
              metricsContent += `<p><strong>Optimization:</strong> ${metric.lower_is_better ? 'Minimize' : 'Maximize'}</p>`;

              // Create table for dataset values
              metricsContent += `<table class="metric-table">
                  <tr>
                      <th>Dataset</th>
                      <th>Final Value</th>
                      <th>Best Value</th>
                  </tr>`;

              for (const dataPoint of metric.data) {
                  metricsContent += `<tr>
                      <td>${dataPoint.dataset_name}</td>
                      <td>${dataPoint.final_value?.toFixed(4) || 'N/A'}</td>
                      <td>${dataPoint.best_value?.toFixed(4) || 'N/A'}</td>
                  </tr>`;
              }

              metricsContent += `</table></div>`;
          }
      } else if (metrics === null) {
          metricsContent += `<p>No metrics available</p>`;
      }
      metricsElm.innerHTML = metricsContent;
  }

  // Add plots display
  const plotsElm = document.getElementById("plots");
  if (plotsElm) {
      if (plots && plots.length > 0) {
          let plotsContent = '';
          plots.forEach(plotPath => {
              plotsContent += `
                  <div class="plot-item">
                      <img src="${plotPath}" alt="Experiment Plot" onerror="console.error('Failed to load plot:', this.src)"/>
                  </div>`;
          });
          plotsElm.innerHTML = plotsContent;
      } else {
          plotsElm.innerHTML = '';
      }
  }

  // Add error info display
  const errorElm = document.getElementById("exc_info");
  if (errorElm) {
    if (exc_type) {
      let errorContent = `<h3 style="color: #ff5555">Exception Information:</h3>
                          <p><strong>Type:</strong> ${exc_type}</p>`;

      if (exc_info) {
        errorContent += `<p><strong>Details:</strong> <pre>${JSON.stringify(exc_info, null, 2)}</pre></p>`;
      }

      if (exc_stack) {
        errorContent += `<p><strong>Stack Trace:</strong> <pre>${exc_stack.join('\n')}</pre></p>`;
      }

      errorElm.innerHTML = errorContent;
    } else {
      errorElm.innerHTML = "No exception info available";
    }
  }

  const exec_timeElm = document.getElementById("exec_time");
  if (exec_timeElm) {
    let exec_timeContent = '<div id="exec_time"><h3>Execution Time (in seconds):</h3><p>' + exec_time + '</p></div>';
    exec_timeElm.innerHTML = exec_timeContent;
  }

  const exec_time_feedbackElm = document.getElementById("exec_time_feedback");
  if (exec_time_feedbackElm) {
    let exec_time_feedbackContent = '<div id="exec_time_feedback_content">'
    exec_time_feedbackContent += '<h3>Execution Time Feedback:</h3>'
    exec_time_feedbackContent += '<p>' + exec_time_feedback + '</p>'
    exec_time_feedbackContent += '</div>';
    exec_time_feedbackElm.innerHTML = exec_time_feedbackContent;
  }

  const vlm_feedbackElm = document.getElementById("vlm_feedback");
  if (vlm_feedbackElm) {
      let vlm_feedbackContent = '';

      if (plot_analyses && plot_analyses.length > 0) {
          vlm_feedbackContent += `<h3>Plot Analysis:</h3>`;
          plot_analyses.forEach(analysis => {
              if (analysis && analysis.plot_path) {  // Add null check
                  vlm_feedbackContent += `
                      <div class="plot-analysis">
                          <h4>Analysis for ${analysis.plot_path.split('/').pop()}</h4>
                          <p>${analysis.analysis || 'No analysis available'}</p>
                          <ul class="key-findings">
                              ${(analysis.key_findings || []).map(finding => `<li>${finding}</li>`).join('')}
                          </ul>
                      </div>`;
              } else {
                  console.warn('Received invalid plot analysis:', analysis);
                  vlm_feedbackContent += `
                      <div class="plot-analysis">
                          <p>Invalid plot analysis data received</p>
                      </div>`;
              }
          });
      }

      // Add actionable insights if available
      if (vlm_feedback_summary && typeof vlm_feedback_summary === 'string') {
          vlm_feedbackContent += `
              <div class="vlm_feedback">
                  <h3>VLM Feedback Summary:</h3>
                  <p>${vlm_feedback_summary}</p>
              </div>`;
      }

      console.log("Datasets successfully tested:", datasets_successfully_tested);
      if (datasets_successfully_tested && datasets_successfully_tested.length > 0) {
          vlm_feedbackContent += `
              <div id="datasets_successfully_tested">
                  <h3>Datasets Successfully Tested:</h3>
                  <p>${datasets_successfully_tested.join(', ')}</p>
              </div>`;
      }

      if (!vlm_feedbackContent) {
          vlm_feedbackContent = '<p>No insights available for this experiment.</p>';
      }

      vlm_feedbackElm.innerHTML = vlm_feedbackContent;
  }

  const datasets_successfully_testedElm = document.getElementById("datasets_successfully_tested");
  if (datasets_successfully_testedElm) {
      let datasets_successfully_testedContent = '';
      if (datasets_successfully_tested && datasets_successfully_tested.length > 0) {
          datasets_successfully_testedContent = `<h3>Datasets Successfully Tested:</h3><ul>`;
          datasets_successfully_tested.forEach(dataset => {
              datasets_successfully_testedContent += `<li>${dataset}</li>`;
          });
          datasets_successfully_testedContent += `</ul>`;
      } else {
          datasets_successfully_testedContent = '<p>No datasets tested yet</p>';
      }
      datasets_successfully_testedElm.innerHTML = datasets_successfully_testedContent;
  }
};

// Initialize with the provided tree data
const treeStructData = {"edges": [[0, 1], [0, 2], [0, 3], [0, 4]], "layout": [[0.5, 0.0], [0.0, 1.0], [0.3333333333333333, 1.0], [0.6666666666666666, 1.0], [1.0, 1.0]], "plan": ["We start with a simple yet competitive baseline that does not perform any\nexplicit glyph clustering; instead, each glyph is treated as a token and\nsequences are vectorised with a Bag-of-Tokens model (scikit-learn\u2019s\nCountVectorizer).  The resulting sparse counts are converted to dense tensors\nand fed to a small two-layer feed-forward network trained with cross-entropy.\nLabels are automatically integer-encoded.  Training proceeds for a few epochs\nwith mini-batches, reporting validation loss plus Accuracy, CWA, SWA and the\nrequested Complexity-Weighted Accuracy (CompWA) after every epoch.  All metrics,\nlosses, predictions and ground-truth labels are stored in a structured\nexperiment_data dict and saved as a .npy file in the mandated ./working\ndirectory.  If the SPR_BENCH dataset is absent the script falls back to a tiny\nsynthetic dataset so it can run anywhere.  The model, data and every batch are\nmoved to GPU when available, satisfying device-handling requirements.  This\nestablishes a fully functional end-to-end pipeline (data \u2192 model \u2192 evaluation \u2192\npersistence) on which more sophisticated glyph-clustering ideas can be layered\nlater.", "Hyperparam tuning name: epochs. The solution runs several independent trainings\nwith different `epochs` settings (5 / 10 / 20 / 30).   For every setting the\nmodel is re-initialised, trained, validated each epoch, then finally evaluated\non the test split.   All losses, metrics, predictions, etc. are stored under\nexperiment_data['epoch_tuning']['SPR_BENCH']['epochs_<N>'] = {...}  and the\nwhole structure is saved to `experiment_data.npy`.", "Hyperparam tuning name: learning_rate. We sweep over a small logarithmic grid of\nAdam learning-rates (1e-4, 3e-4, 1e-3, 3e-3).   For every rate we rebuild the\nmodel, train it for five epochs, track losses and (weighted) accuracies epoch-\nby-epoch, then evaluate on the test split.   The results of each run are stored\nin experiment_data['learning_rate']['SPR_BENCH']['runs'] so that later analysis\nor plotting can compare curves across rates.   Everything (metrics, losses,\npredictions, etc.) is finally saved to working/experiment_data.npy.", "Hyperparam tuning name: batch_size. We sweep over several mini-batch sizes (16,\n32, 64, 128).   For each value we rebuild the MLP, create the corresponding\nDataLoaders, train for a few epochs, evaluate on dev and test, and store all\nlosses/metrics/predictions in a structured `experiment_data` dict.   At the end\nthe whole dictionary is saved as `experiment_data.npy`, ready for plotting or\nfurther analysis.", "Hyperparam tuning name: weight_decay. We extend the baseline by sweeping Adam\u2019s\nweight_decay hyper-parameter over five values (0, 1e-5, 1e-4, 1e-3, 1e-2).   For\neach setting we (1) re-instantiate the MLP and optimizer with the chosen\ncoefficient, (2) train for the same epochs, (3) log per-epoch train/validation\nlosses and weighted accuracies, and (4) evaluate on the test split.   All\nresults are collected in a nested experiment_data dictionary under the key\n'weight_decay' and saved to experiment_data.npy at the end."], "code": ["import os\n\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom datasets import load_dataset, DatasetDict\nimport pathlib\nfrom typing import List\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(f\"Using device: {device}\")\n\nexperiment_data = {\n    \"SPR_BENCH\": {\n        \"metrics\": {\"train\": [], \"val\": []},\n        \"losses\": {\"train\": [], \"val\": []},\n        \"predictions\": [],\n        \"ground_truth\": [],\n        \"sequences\": [],\n    }\n}\n\n\n# ---------- Utility functions & metrics ----------\ndef load_spr_bench(root: pathlib.Path) -> DatasetDict:\n    def _load(split_csv: str):\n        return load_dataset(\n            \"csv\",\n            data_files=str(root / split_csv),\n            split=\"train\",\n            cache_dir=\".cache_dsets\",\n        )\n\n    dset = DatasetDict()\n    for split in [\"train\", \"dev\", \"test\"]:\n        dset[split] = _load(f\"{split}.csv\")\n    return dset\n\n\ndef count_color_variety(sequence: str) -> int:\n    return len(set(tok[1] for tok in sequence.strip().split() if len(tok) > 1))\n\n\ndef count_shape_variety(sequence: str) -> int:\n    return len(set(tok[0] for tok in sequence.strip().split() if tok))\n\n\ndef color_weighted_accuracy(seqs, y_true, y_pred):\n    weights = [count_color_variety(s) for s in seqs]\n    correct = [w if t == p else 0 for w, t, p in zip(weights, y_true, y_pred)]\n    return sum(correct) / sum(weights) if sum(weights) else 0.0\n\n\ndef shape_weighted_accuracy(seqs, y_true, y_pred):\n    weights = [count_shape_variety(s) for s in seqs]\n    correct = [w if t == p else 0 for w, t, p in zip(weights, y_true, y_pred)]\n    return sum(correct) / sum(weights) if sum(weights) else 0.0\n\n\ndef complexity_weighted_accuracy(seqs, y_true, y_pred):\n    weights = [count_color_variety(s) * count_shape_variety(s) for s in seqs]\n    correct = [w if t == p else 0 for w, t, p in zip(weights, y_true, y_pred)]\n    return sum(correct) / sum(weights) if sum(weights) else 0.0\n\n\n# -------------------------------------------------\n\n# ---------- Load data (fallback to synthetic) ----------\nDATA_ENV = os.getenv(\"SPR_BENCH_PATH\", \"/home/zxl240011/AI-Scientist-v2/SPR_BENCH/\")\ndataset_available = pathlib.Path(DATA_ENV).exists()\nif dataset_available:\n    dsets = load_spr_bench(pathlib.Path(DATA_ENV))\nelse:\n    print(\"SPR_BENCH not found. Creating synthetic data for demo.\")\n\n    def synth_split(n):\n        seqs, labels = [], []\n        shapes = [\"\u25b2\", \"\u25cf\", \"\u25a0\"]\n        colors = [\"r\", \"g\", \"b\"]\n        for i in range(n):\n            seq = \" \".join(\n                np.random.choice(\n                    [s + c for s in shapes for c in colors],\n                    size=np.random.randint(3, 8),\n                )\n            )\n            label = np.random.choice([\"A\", \"B\", \"C\"])\n            seqs.append(seq)\n            labels.append(label)\n        return {\"sequence\": seqs, \"label\": labels}\n\n    dsets = DatasetDict()\n    for split, n in zip([\"train\", \"dev\", \"test\"], [200, 50, 50]):\n        dsets[split] = load_dataset(\n            \"json\", data_files={\"train\": synth_split(n)}, split=\"train\"\n        )\n# --------------------------------------------------------\n\n# ---------- Text vectorisation ----------\nvectorizer = CountVectorizer(token_pattern=r\"[^ ]+\")\nvectorizer.fit(dsets[\"train\"][\"sequence\"])\nvocab_size = len(vectorizer.vocabulary_)\nprint(f\"Vocabulary size: {vocab_size}\")\n\n\ndef vectorize(seqs: List[str]) -> np.ndarray:\n    return vectorizer.transform(seqs).toarray().astype(np.float32)\n\n\nX_train = vectorize(dsets[\"train\"][\"sequence\"])\nX_val = vectorize(dsets[\"dev\"][\"sequence\"])\nX_test = vectorize(dsets[\"test\"][\"sequence\"])\n\n# ---------- Label encoding ----------\nlabels = sorted(list(set(dsets[\"train\"][\"label\"])))\nlabel2id = {l: i for i, l in enumerate(labels)}\nid2label = {i: l for l, i in label2id.items()}\n\ny_train = np.array([label2id[l] for l in dsets[\"train\"][\"label\"]], dtype=np.int64)\ny_val = np.array([label2id[l] for l in dsets[\"dev\"][\"label\"]], dtype=np.int64)\ny_test = np.array([label2id[l] for l in dsets[\"test\"][\"label\"]], dtype=np.int64)\nnum_classes = len(labels)\nprint(f\"Number of classes: {num_classes}\")\n\n# ---------- DataLoader ----------\nbatch_size = 64\ntrain_loader = DataLoader(\n    TensorDataset(torch.from_numpy(X_train), torch.from_numpy(y_train)),\n    batch_size=batch_size,\n    shuffle=True,\n)\nval_loader = DataLoader(\n    TensorDataset(torch.from_numpy(X_val), torch.from_numpy(y_val)),\n    batch_size=batch_size,\n)\n\n\n# ---------- Model ----------\nclass MLP(nn.Module):\n    def __init__(self, in_dim, num_classes):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(in_dim, 256), nn.ReLU(), nn.Linear(256, num_classes)\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\nmodel = MLP(vocab_size, num_classes).to(device)\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\n\n# ---------- Training ----------\nepochs = 5\nfor epoch in range(1, epochs + 1):\n    model.train()\n    running_loss = 0.0\n    for xb, yb in train_loader:\n        xb, yb = xb.to(device), yb.to(device)\n        optimizer.zero_grad()\n        logits = model(xb)\n        loss = criterion(logits, yb)\n        loss.backward()\n        optimizer.step()\n        running_loss += loss.item() * xb.size(0)\n    train_loss = running_loss / len(train_loader.dataset)\n    experiment_data[\"SPR_BENCH\"][\"losses\"][\"train\"].append(train_loss)\n\n    # ---------- Validation ----------\n    model.eval()\n    val_loss = 0.0\n    all_preds, all_tgts, all_seqs = [], [], []\n    with torch.no_grad():\n        for xb, yb in val_loader:\n            xb, yb = xb.to(device), yb.to(device)\n            logits = model(xb)\n            loss = criterion(logits, yb)\n            val_loss += loss.item() * xb.size(0)\n            preds = logits.argmax(dim=1).cpu().numpy()\n            all_preds.extend(preds)\n            all_tgts.extend(yb.cpu().numpy())\n    val_loss /= len(val_loader.dataset)\n    experiment_data[\"SPR_BENCH\"][\"losses\"][\"val\"].append(val_loss)\n\n    sequences_val = dsets[\"dev\"][\"sequence\"]\n    acc = (np.array(all_preds) == np.array(all_tgts)).mean()\n    cwa = color_weighted_accuracy(sequences_val, all_tgts, all_preds)\n    swa = shape_weighted_accuracy(sequences_val, all_tgts, all_preds)\n    comp = complexity_weighted_accuracy(sequences_val, all_tgts, all_preds)\n\n    experiment_data[\"SPR_BENCH\"][\"metrics\"][\"val\"].append(\n        {\"epoch\": epoch, \"acc\": acc, \"cwa\": cwa, \"swa\": swa, \"compwa\": comp}\n    )\n    print(\n        f\"Epoch {epoch}: train_loss={train_loss:.4f}  validation_loss={val_loss:.4f}  \"\n        f\"ACC={acc:.3f}  CWA={cwa:.3f}  SWA={swa:.3f}  CompWA={comp:.3f}\"\n    )\n\n# ---------- Final evaluation on test ----------\nwith torch.no_grad():\n    X_test_tensor = torch.from_numpy(X_test).to(device)\n    test_logits = model(X_test_tensor)\n    test_preds = test_logits.argmax(dim=1).cpu().numpy()\ntest_sequences = dsets[\"test\"][\"sequence\"]\ntest_acc = (test_preds == y_test).mean()\ntest_cwa = color_weighted_accuracy(test_sequences, y_test, test_preds)\ntest_swa = shape_weighted_accuracy(test_sequences, y_test, test_preds)\ntest_comp = complexity_weighted_accuracy(test_sequences, y_test, test_preds)\n\nexperiment_data[\"SPR_BENCH\"][\"predictions\"] = test_preds\nexperiment_data[\"SPR_BENCH\"][\"ground_truth\"] = y_test\nexperiment_data[\"SPR_BENCH\"][\"sequences\"] = test_sequences\nexperiment_data[\"SPR_BENCH\"][\"metrics\"][\"test\"] = {\n    \"acc\": test_acc,\n    \"cwa\": test_cwa,\n    \"swa\": test_swa,\n    \"compwa\": test_comp,\n}\n\nprint(\n    f\"\\nTest set \u2014  ACC={test_acc:.3f}  CWA={test_cwa:.3f}  \"\n    f\"SWA={test_swa:.3f}  CompWA={test_comp:.3f}\"\n)\n\n# ---------- Save experiment data ----------\nnp.save(\n    os.path.join(working_dir, \"experiment_data.npy\"), experiment_data, allow_pickle=True\n)\nprint(f\"Saved experiment data to {os.path.join(working_dir, 'experiment_data.npy')}\")\n", "import os, pathlib, numpy as np, torch, torch.nn as nn\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom datasets import load_dataset, DatasetDict\nfrom typing import List\n\n# ---------- basic setup ----------\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\n\nexperiment_data = {\"epoch_tuning\": {\"SPR_BENCH\": {}}}\n\n\n# ---------- load (or build) SPR-BENCH ----------\ndef load_spr_bench(root: pathlib.Path) -> DatasetDict:\n    def _load(csv_name):  # helper\n        return load_dataset(\n            \"csv\",\n            data_files=str(root / csv_name),\n            split=\"train\",\n            cache_dir=\".cache_dsets\",\n        )\n\n    out = DatasetDict()\n    for split in [\"train\", \"dev\", \"test\"]:\n        out[split] = _load(f\"{split}.csv\")\n    return out\n\n\nDATA_ENV = os.getenv(\"SPR_BENCH_PATH\", \"/home/zxl240011/AI-Scientist-v2/SPR_BENCH/\")\nif pathlib.Path(DATA_ENV).exists():\n    dsets = load_spr_bench(pathlib.Path(DATA_ENV))\nelse:  # synthetic fallback\n\n    def _synthetic(n):\n        shapes, colors = [\"\u25b2\", \"\u25cf\", \"\u25a0\"], [\"r\", \"g\", \"b\"]\n        seqs, labels = [], []\n        for _ in range(n):\n            seqs.append(\n                \" \".join(\n                    np.random.choice(\n                        [s + c for s in shapes for c in colors],\n                        size=np.random.randint(3, 8),\n                    )\n                )\n            )\n            labels.append(np.random.choice([\"A\", \"B\", \"C\"]))\n        return {\"sequence\": seqs, \"label\": labels}\n\n    dsets = DatasetDict()\n    for split, n in [(\"train\", 200), (\"dev\", 50), (\"test\", 50)]:\n        dsets[split] = load_dataset(\n            \"json\", data_files={\"train\": _synthetic(n)}, split=\"train\"\n        )\n\n\n# ---------- auxiliary metrics ----------\ndef _color_var(seq):\n    return len({tok[1] for tok in seq.split() if len(tok) > 1})\n\n\ndef _shape_var(seq):\n    return len({tok[0] for tok in seq.split()})\n\n\ndef _wacc(seqs, y_true, y_pred, wfunc):\n    w = [wfunc(s) for s in seqs]\n    corr = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(corr) / sum(w) if sum(w) else 0.0\n\n\ndef cwa(s, y, yhat):\n    return _wacc(s, y, yhat, _color_var)\n\n\ndef swa(s, y, yhat):\n    return _wacc(s, y, yhat, _shape_var)\n\n\ndef compwa(s, y, yhat):\n    return _wacc(s, y, yhat, lambda x: _color_var(x) * _shape_var(x))\n\n\n# ---------- vectoriser ----------\nvectoriser = CountVectorizer(token_pattern=r\"[^ ]+\")\nvectoriser.fit(dsets[\"train\"][\"sequence\"])\nvocab_size = len(vectoriser.vocabulary_)\n\n\ndef vec(batch: List[str]):\n    return vectoriser.transform(batch).toarray().astype(np.float32)\n\n\n# ---------- label encoding ----------\nlabels = sorted(set(dsets[\"train\"][\"label\"]))\nlab2id = {l: i for i, l in enumerate(labels)}\nid2lab = {i: l for l, i in lab2id.items()}\nnum_classes = len(labels)\n\ny_train = np.array([lab2id[l] for l in dsets[\"train\"][\"label\"]], np.int64)\ny_val = np.array([lab2id[l] for l in dsets[\"dev\"][\"label\"]], np.int64)\ny_test = np.array([lab2id[l] for l in dsets[\"test\"][\"label\"]], np.int64)\nX_train, X_val, X_test = map(\n    vec,\n    [dsets[\"train\"][\"sequence\"], dsets[\"dev\"][\"sequence\"], dsets[\"test\"][\"sequence\"]],\n)\n\n\n# ---------- model definition ----------\nclass MLP(nn.Module):\n    def __init__(self, din, ncls):\n        super().__init__()\n        self.net = nn.Sequential(nn.Linear(din, 256), nn.ReLU(), nn.Linear(256, ncls))\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# ---------- training routine ----------\ndef run_experiment(num_epochs: int, batch=64, lr=1e-3):\n    torch.manual_seed(0)\n    np.random.seed(0)\n    model = MLP(vocab_size, num_classes).to(device)\n    opt = torch.optim.Adam(model.parameters(), lr=lr)\n    crit = nn.CrossEntropyLoss()\n    tl, vl, v_metrics = [], [], []\n    tr_loader = DataLoader(\n        TensorDataset(torch.from_numpy(X_train), torch.from_numpy(y_train)),\n        batch_size=batch,\n        shuffle=True,\n    )\n    val_loader = DataLoader(\n        TensorDataset(torch.from_numpy(X_val), torch.from_numpy(y_val)),\n        batch_size=batch,\n    )\n    for epoch in range(1, num_epochs + 1):\n        # train\n        model.train()\n        run_loss = 0.0\n        for xb, yb in tr_loader:\n            xb, yb = xb.to(device), yb.to(device)\n            opt.zero_grad()\n            logits = model(xb)\n            loss = crit(logits, yb)\n            loss.backward()\n            opt.step()\n            run_loss += loss.item() * xb.size(0)\n        tl.append(run_loss / len(tr_loader.dataset))\n        # validate\n        model.eval()\n        vloss, preds, tgts = 0.0, [], []\n        with torch.no_grad():\n            for xb, yb in val_loader:\n                xb, yb = xb.to(device), yb.to(device)\n                logits = model(xb)\n                loss = crit(logits, yb)\n                vloss += loss.item() * xb.size(0)\n                preds.extend(logits.argmax(1).cpu().numpy())\n                tgts.extend(yb.cpu().numpy())\n        vloss /= len(val_loader.dataset)\n        vl.append(vloss)\n        seqs_val = dsets[\"dev\"][\"sequence\"]\n        acc = (np.array(preds) == np.array(tgts)).mean()\n        v_metrics.append(\n            {\n                \"epoch\": epoch,\n                \"acc\": acc,\n                \"cwa\": cwa(seqs_val, tgts, preds),\n                \"swa\": swa(seqs_val, tgts, preds),\n                \"compwa\": compwa(seqs_val, tgts, preds),\n            }\n        )\n    # test\n    with torch.no_grad():\n        test_logits = model(torch.from_numpy(X_test).to(device))\n        test_preds = test_logits.argmax(1).cpu().numpy()\n    test_metrics = {\n        \"acc\": (test_preds == y_test).mean(),\n        \"cwa\": cwa(dsets[\"test\"][\"sequence\"], y_test, test_preds),\n        \"swa\": swa(dsets[\"test\"][\"sequence\"], y_test, test_preds),\n        \"compwa\": compwa(dsets[\"test\"][\"sequence\"], y_test, test_preds),\n    }\n    return {\n        \"losses\": {\"train\": tl, \"val\": vl},\n        \"metrics\": {\"val\": v_metrics, \"test\": test_metrics},\n        \"predictions\": test_preds,\n        \"ground_truth\": y_test,\n        \"sequences\": dsets[\"test\"][\"sequence\"],\n    }\n\n\n# ---------- hyper-parameter sweep ----------\nfor ep in [5, 10, 20, 30]:\n    print(f\"\\n=== Training with {ep} epochs ===\")\n    res = run_experiment(ep)\n    experiment_data[\"epoch_tuning\"][\"SPR_BENCH\"][f\"epochs_{ep}\"] = res\n    tm = res[\"metrics\"][\"test\"]\n    print(\n        f\"Test  ACC={tm['acc']:.3f}  CWA={tm['cwa']:.3f}  SWA={tm['swa']:.3f} \"\n        f\"CompWA={tm['compwa']:.3f}\"\n    )\n\n# ---------- save ----------\nnp.save(\n    os.path.join(working_dir, \"experiment_data.npy\"), experiment_data, allow_pickle=True\n)\nprint(f\"\\nSaved results to {os.path.join(working_dir,'experiment_data.npy')}\")\n", "import os, pathlib, numpy as np, torch, torch.nn as nn\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom datasets import load_dataset, DatasetDict\nfrom typing import List\n\n# ------------------- I/O & bookkeeping -------------------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\nexperiment_data = {\n    \"learning_rate\": {\n        \"SPR_BENCH\": {\"runs\": []}  # each element is a dict with info for one lr value\n    }\n}\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(\"Running on\", device)\n\n\n# ------------------- helper functions --------------------\ndef load_spr_bench(root: pathlib.Path) -> DatasetDict:\n    def _load(split_csv: str):\n        return load_dataset(\n            \"csv\",\n            data_files=str(root / split_csv),\n            split=\"train\",\n            cache_dir=\".cache_dsets\",\n        )\n\n    return DatasetDict({s: _load(f\"{s}.csv\") for s in [\"train\", \"dev\", \"test\"]})\n\n\ndef count_color_variety(sequence: str) -> int:\n    return len(set(tok[1] for tok in sequence.strip().split() if len(tok) > 1))\n\n\ndef count_shape_variety(sequence: str) -> int:\n    return len(set(tok[0] for tok in sequence.strip().split() if tok))\n\n\ndef color_weighted_accuracy(seqs, y_true, y_pred):\n    w = [count_color_variety(s) for s in seqs]\n    c = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\ndef shape_weighted_accuracy(seqs, y_true, y_pred):\n    w = [count_shape_variety(s) for s in seqs]\n    c = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\ndef complexity_weighted_accuracy(seqs, y_true, y_pred):\n    w = [count_color_variety(s) * count_shape_variety(s) for s in seqs]\n    c = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\n# ------------------- load dataset ------------------------\nDATA_ENV = os.getenv(\"SPR_BENCH_PATH\", \"/home/zxl240011/AI-Scientist-v2/SPR_BENCH/\")\nif pathlib.Path(DATA_ENV).exists():\n    dsets = load_spr_bench(pathlib.Path(DATA_ENV))\nelse:  # synthetic fallback\n    print(\"SPR_BENCH not found -> generating synthetic demo data.\")\n\n    def synth_split(n):\n        shapes, colors = [\"\u25b2\", \"\u25cf\", \"\u25a0\"], [\"r\", \"g\", \"b\"]\n        seq, lab = [], []\n        for _ in range(n):\n            seq.append(\n                \" \".join(\n                    np.random.choice(\n                        [s + c for s in shapes for c in colors],\n                        size=np.random.randint(3, 8),\n                    )\n                )\n            )\n            lab.append(np.random.choice([\"A\", \"B\", \"C\"]))\n        return {\"sequence\": seq, \"label\": lab}\n\n    dsets = DatasetDict()\n    for split, n in zip([\"train\", \"dev\", \"test\"], [200, 50, 50]):\n        dsets[split] = load_dataset(\n            \"json\", data_files={\"train\": synth_split(n)}, split=\"train\"\n        )\n\n# ------------------- vectorise text ----------------------\nvectorizer = CountVectorizer(token_pattern=r\"[^ ]+\")\nvectorizer.fit(dsets[\"train\"][\"sequence\"])\nvocab_size = len(vectorizer.vocabulary_)\nprint(\"Vocabulary size:\", vocab_size)\n\n\ndef vectorize(seqs: List[str]) -> np.ndarray:\n    return vectorizer.transform(seqs).toarray().astype(np.float32)\n\n\nX_train, X_val, X_test = map(\n    vectorize,\n    (dsets[\"train\"][\"sequence\"], dsets[\"dev\"][\"sequence\"], dsets[\"test\"][\"sequence\"]),\n)\n\n# ------------------- labels ------------------------------\nlabels = sorted(set(dsets[\"train\"][\"label\"]))\nlabel2id = {l: i for i, l in enumerate(labels)}\ny_train = np.array([label2id[l] for l in dsets[\"train\"][\"label\"]], np.int64)\ny_val = np.array([label2id[l] for l in dsets[\"dev\"][\"label\"]], np.int64)\ny_test = np.array([label2id[l] for l in dsets[\"test\"][\"label\"]], np.int64)\nnum_classes = len(labels)\n\n# ------------------- data loaders ------------------------\nbatch_size = 64\ntrain_loader = DataLoader(\n    TensorDataset(torch.from_numpy(X_train), torch.from_numpy(y_train)),\n    batch_size=batch_size,\n    shuffle=True,\n)\nval_loader = DataLoader(\n    TensorDataset(torch.from_numpy(X_val), torch.from_numpy(y_val)),\n    batch_size=batch_size,\n)\n\n\n# ------------------- model def ---------------------------\nclass MLP(nn.Module):\n    def __init__(self, in_dim, num_classes):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(in_dim, 256), nn.ReLU(), nn.Linear(256, num_classes)\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# ------------------- LR SWEEP ----------------------------\nlr_grid = [1e-4, 3e-4, 1e-3, 3e-3]\nepochs = 5\n\nfor lr in lr_grid:\n    print(f\"\\n=== Training with learning rate = {lr:.0e} ===\")\n    model = MLP(vocab_size, num_classes).to(device)\n    criterion = nn.CrossEntropyLoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=lr)\n\n    run_data = {\n        \"lr\": lr,\n        \"metrics\": {\"train\": [], \"val\": [], \"test\": None},\n        \"losses\": {\"train\": [], \"val\": []},\n        \"predictions\": [],\n        \"ground_truth\": [],\n        \"sequences\": [],\n    }\n\n    for epoch in range(1, epochs + 1):\n        # ---- train pass ----\n        model.train()\n        running_loss = 0.0\n        correct, total = 0, 0\n        for xb, yb in train_loader:\n            xb, yb = xb.to(device), yb.to(device)\n            optimizer.zero_grad()\n            logits = model(xb)\n            loss = criterion(logits, yb)\n            loss.backward()\n            optimizer.step()\n            running_loss += loss.item() * xb.size(0)\n            correct += (logits.argmax(1) == yb).sum().item()\n            total += yb.size(0)\n        train_loss = running_loss / len(train_loader.dataset)\n        train_acc = correct / total\n        run_data[\"losses\"][\"train\"].append(train_loss)\n        run_data[\"metrics\"][\"train\"].append({\"epoch\": epoch, \"acc\": train_acc})\n\n        # ---- validation ----\n        model.eval()\n        val_loss, preds, tgts = 0.0, [], []\n        with torch.no_grad():\n            for xb, yb in val_loader:\n                xb, yb = xb.to(device), yb.to(device)\n                logits = model(xb)\n                loss = criterion(logits, yb)\n                val_loss += loss.item() * xb.size(0)\n                preds.extend(logits.argmax(1).cpu().numpy())\n                tgts.extend(yb.cpu().numpy())\n        val_loss /= len(val_loader.dataset)\n        run_data[\"losses\"][\"val\"].append(val_loss)\n\n        seqs_val = dsets[\"dev\"][\"sequence\"]\n        acc = (np.array(preds) == np.array(tgts)).mean()\n        cwa = color_weighted_accuracy(seqs_val, tgts, preds)\n        swa = shape_weighted_accuracy(seqs_val, tgts, preds)\n        comp = complexity_weighted_accuracy(seqs_val, tgts, preds)\n        run_data[\"metrics\"][\"val\"].append(\n            {\"epoch\": epoch, \"acc\": acc, \"cwa\": cwa, \"swa\": swa, \"compwa\": comp}\n        )\n\n        print(\n            f\"Epoch {epoch}: train_loss={train_loss:.4f} val_loss={val_loss:.4f} \"\n            f\"ACC={acc:.3f} CWA={cwa:.3f} SWA={swa:.3f} CompWA={comp:.3f}\"\n        )\n\n    # ------------- test pass ---------------\n    with torch.no_grad():\n        logits_test = model(torch.from_numpy(X_test).to(device))\n        test_preds = logits_test.argmax(1).cpu().numpy()\n    test_seqs = dsets[\"test\"][\"sequence\"]\n    test_acc = (test_preds == y_test).mean()\n    test_cwa = color_weighted_accuracy(test_seqs, y_test, test_preds)\n    test_swa = shape_weighted_accuracy(test_seqs, y_test, test_preds)\n    test_comp = complexity_weighted_accuracy(test_seqs, y_test, test_preds)\n    run_data[\"metrics\"][\"test\"] = {\n        \"acc\": test_acc,\n        \"cwa\": test_cwa,\n        \"swa\": test_swa,\n        \"compwa\": test_comp,\n    }\n    run_data[\"predictions\"] = test_preds\n    run_data[\"ground_truth\"] = y_test\n    run_data[\"sequences\"] = test_seqs\n\n    print(\n        f\"Test \u2014 ACC={test_acc:.3f} CWA={test_cwa:.3f} \"\n        f\"SWA={test_swa:.3f} CompWA={test_comp:.3f}\"\n    )\n\n    experiment_data[\"learning_rate\"][\"SPR_BENCH\"][\"runs\"].append(run_data)\n\n# ------------------- save everything ---------------------\nnp.save(\n    os.path.join(working_dir, \"experiment_data.npy\"), experiment_data, allow_pickle=True\n)\nprint(\"Saved experiment data to\", os.path.join(working_dir, \"experiment_data.npy\"))\n", "import os, pathlib, numpy as np, torch, torch.nn as nn\nfrom torch.utils.data import TensorDataset, DataLoader\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom datasets import load_dataset, DatasetDict\nfrom typing import List\n\n# ---------- bookkeeping ----------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\nexperiment_data = {\n    \"batch_size\": {  # hyper-parameter we sweep\n        \"SPR_BENCH\": {\"runs\": []}  # list of per-batch-size dicts\n    }\n}\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(f\"Using device: {device}\")\n\n\n# ---------- helper functions ----------\ndef load_spr_bench(root: pathlib.Path) -> DatasetDict:\n    def _load(split_csv: str):\n        return load_dataset(\n            \"csv\",\n            data_files=str(root / split_csv),\n            split=\"train\",\n            cache_dir=\".cache_dsets\",\n        )\n\n    dset = DatasetDict()\n    for split in [\"train\", \"dev\", \"test\"]:\n        dset[split] = _load(f\"{split}.csv\")\n    return dset\n\n\ndef count_color_variety(seq: str) -> int:\n    return len(set(tok[1] for tok in seq.strip().split() if len(tok) > 1))\n\n\ndef count_shape_variety(seq: str) -> int:\n    return len(set(tok[0] for tok in seq.strip().split() if tok))\n\n\ndef color_weighted_accuracy(seqs, y_true, y_pred):\n    w = [count_color_variety(s) for s in seqs]\n    c = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\ndef shape_weighted_accuracy(seqs, y_true, y_pred):\n    w = [count_shape_variety(s) for s in seqs]\n    c = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\ndef complexity_weighted_accuracy(seqs, y_true, y_pred):\n    w = [count_shape_variety(s) * count_color_variety(s) for s in seqs]\n    c = [wt if t == p else 0 for wt, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\n# ---------- data ----------\nDATA_ENV = os.getenv(\"SPR_BENCH_PATH\", \"/home/zxl240011/AI-Scientist-v2/SPR_BENCH/\")\nif pathlib.Path(DATA_ENV).exists():\n    dsets = load_spr_bench(pathlib.Path(DATA_ENV))\nelse:\n    print(\"SPR_BENCH not found \u2013 generating synthetic data.\")\n\n    def synth_split(n):\n        shapes, colors = [\"\u25b2\", \"\u25cf\", \"\u25a0\"], [\"r\", \"g\", \"b\"]\n        seqs, labels = [], []\n        for _ in range(n):\n            seqs.append(\n                \" \".join(\n                    np.random.choice(\n                        [s + c for s in shapes for c in colors],\n                        size=np.random.randint(3, 8),\n                    )\n                )\n            )\n            labels.append(np.random.choice([\"A\", \"B\", \"C\"]))\n        return {\"sequence\": seqs, \"label\": labels}\n\n    dsets = DatasetDict()\n    for split, n in zip([\"train\", \"dev\", \"test\"], [200, 50, 50]):\n        dsets[split] = load_dataset(\n            \"json\", data_files={\"train\": synth_split(n)}, split=\"train\"\n        )\n\nvectorizer = CountVectorizer(token_pattern=r\"[^ ]+\")\nvectorizer.fit(dsets[\"train\"][\"sequence\"])\nvocab_size = len(vectorizer.vocabulary_)\nprint(\"Vocabulary size:\", vocab_size)\n\n\ndef vectorize(seqs: List[str]) -> np.ndarray:\n    return vectorizer.transform(seqs).toarray().astype(np.float32)\n\n\nX_train, X_val, X_test = map(\n    vectorize,\n    (dsets[\"train\"][\"sequence\"], dsets[\"dev\"][\"sequence\"], dsets[\"test\"][\"sequence\"]),\n)\n\nlabels = sorted(set(dsets[\"train\"][\"label\"]))\nlabel2id = {l: i for i, l in enumerate(labels)}\nid2label = {i: l for l, i in label2id.items()}\ny_train = np.array([label2id[l] for l in dsets[\"train\"][\"label\"]], dtype=np.int64)\ny_val = np.array([label2id[l] for l in dsets[\"dev\"][\"label\"]], dtype=np.int64)\ny_test = np.array([label2id[l] for l in dsets[\"test\"][\"label\"]], dtype=np.int64)\nnum_classes = len(labels)\nprint(\"Classes:\", labels)\n\n\n# ---------- model ----------\nclass MLP(nn.Module):\n    def __init__(self, in_dim, out_dim):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(in_dim, 256), nn.ReLU(), nn.Linear(256, out_dim)\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# ---------- hyper-parameter sweep ----------\nbatch_sizes = [16, 32, 64, 128]\nepochs = 5\nfor bs in batch_sizes:\n    print(f\"\\n=== Training with batch_size={bs} ===\")\n    run_record = {\n        \"batch_size\": bs,\n        \"metrics\": {\"train\": [], \"val\": [], \"test\": {}},\n        \"losses\": {\"train\": [], \"val\": []},\n        \"predictions\": [],\n        \"ground_truth\": y_test,\n        \"sequences\": dsets[\"test\"][\"sequence\"],\n    }\n\n    # DataLoaders\n    train_loader = DataLoader(\n        TensorDataset(torch.from_numpy(X_train), torch.from_numpy(y_train)),\n        batch_size=bs,\n        shuffle=True,\n    )\n    val_loader = DataLoader(\n        TensorDataset(torch.from_numpy(X_val), torch.from_numpy(y_val)), batch_size=bs\n    )\n\n    # fresh model\n    model = MLP(vocab_size, num_classes).to(device)\n    optim = torch.optim.Adam(model.parameters(), lr=1e-3)\n    crit = nn.CrossEntropyLoss()\n\n    # training loop\n    for epoch in range(1, epochs + 1):\n        model.train()\n        running_loss = 0.0\n        for xb, yb in train_loader:\n            xb, yb = xb.to(device), yb.to(device)\n            optim.zero_grad()\n            loss = crit(model(xb), yb)\n            loss.backward()\n            optim.step()\n            running_loss += loss.item() * xb.size(0)\n        train_loss = running_loss / len(train_loader.dataset)\n        run_record[\"losses\"][\"train\"].append(train_loss)\n\n        # validation\n        model.eval()\n        val_loss, preds, tgts = 0.0, [], []\n        with torch.no_grad():\n            for xb, yb in val_loader:\n                xb, yb = xb.to(device), yb.to(device)\n                logits = model(xb)\n                val_loss += crit(logits, yb).item() * xb.size(0)\n                preds.extend(logits.argmax(1).cpu().numpy())\n                tgts.extend(yb.cpu().numpy())\n        val_loss /= len(val_loader.dataset)\n        run_record[\"losses\"][\"val\"].append(val_loss)\n\n        seqs_val = dsets[\"dev\"][\"sequence\"]\n        acc = (np.array(preds) == np.array(tgts)).mean()\n        cwa = color_weighted_accuracy(seqs_val, tgts, preds)\n        swa = shape_weighted_accuracy(seqs_val, tgts, preds)\n        comp = complexity_weighted_accuracy(seqs_val, tgts, preds)\n        run_record[\"metrics\"][\"val\"].append(\n            {\"epoch\": epoch, \"acc\": acc, \"cwa\": cwa, \"swa\": swa, \"compwa\": comp}\n        )\n        print(\n            f\"Epoch {epoch}: loss {train_loss:.3f}/{val_loss:.3f} \"\n            f\"ACC {acc:.3f} CWA {cwa:.3f} SWA {swa:.3f} CompWA {comp:.3f}\"\n        )\n\n    # final test evaluation\n    with torch.no_grad():\n        logits = model(torch.from_numpy(X_test).to(device))\n        test_preds = logits.argmax(1).cpu().numpy()\n    tacc = (test_preds == y_test).mean()\n    tcwa = color_weighted_accuracy(dsets[\"test\"][\"sequence\"], y_test, test_preds)\n    tswa = shape_weighted_accuracy(dsets[\"test\"][\"sequence\"], y_test, test_preds)\n    tcomp = complexity_weighted_accuracy(dsets[\"test\"][\"sequence\"], y_test, test_preds)\n    run_record[\"metrics\"][\"test\"] = {\n        \"acc\": tacc,\n        \"cwa\": tcwa,\n        \"swa\": tswa,\n        \"compwa\": tcomp,\n    }\n    run_record[\"predictions\"] = test_preds\n    print(f\"Test: ACC {tacc:.3f} CWA {tcwa:.3f} SWA {tswa:.3f} CompWA {tcomp:.3f}\")\n\n    # store\n    experiment_data[\"batch_size\"][\"SPR_BENCH\"][\"runs\"].append(run_record)\n\n# ---------- save ----------\nnp.save(\n    os.path.join(working_dir, \"experiment_data.npy\"), experiment_data, allow_pickle=True\n)\nprint(\"Saved experiment data to\", os.path.join(working_dir, \"experiment_data.npy\"))\n", "import os, pathlib, numpy as np, torch, torch.nn as nn\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom datasets import load_dataset, DatasetDict\nfrom typing import List\n\n# -------------  Set-up & bookkeeping -------------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nprint(f\"Using device: {device}\")\n\nexperiment_data = {\n    \"weight_decay\": {\"SPR_BENCH\": {}}  # hyper-parameter tuning type  # dataset\n}\n\n\n# -------------  Metrics helpers -------------\ndef count_color_variety(seq: str):\n    return len(set(tok[1] for tok in seq.split() if len(tok) > 1))\n\n\ndef count_shape_variety(seq: str):\n    return len(set(tok[0] for tok in seq.split() if tok))\n\n\ndef _wa(seqs, y_true, y_pred, w_fn):\n    w = [w_fn(s) for s in seqs]\n    c = [wi if t == p else 0 for wi, t, p in zip(w, y_true, y_pred)]\n    return sum(c) / sum(w) if sum(w) else 0.0\n\n\ndef color_weighted_accuracy(s, y_t, y_p):\n    return _wa(s, y_t, y_p, count_color_variety)\n\n\ndef shape_weighted_accuracy(s, y_t, y_p):\n    return _wa(s, y_t, y_p, count_shape_variety)\n\n\ndef complexity_weighted_accuracy(s, y_t, y_p):\n    return _wa(\n        s, y_t, y_p, lambda seq: count_color_variety(seq) * count_shape_variety(seq)\n    )\n\n\n# -------------  Load SPR-BENCH or synthetic -------------\nDATA_ENV = os.getenv(\"SPR_BENCH_PATH\", \"/home/zxl240011/AI-Scientist-v2/SPR_BENCH/\")\n\n\ndef load_spr_bench(root: pathlib.Path):\n    def _ld(csv):\n        return load_dataset(\n            \"csv\", data_files=str(root / csv), split=\"train\", cache_dir=\".cache_dsets\"\n        )\n\n    return DatasetDict({spl: _ld(f\"{spl}.csv\") for spl in [\"train\", \"dev\", \"test\"]})\n\n\ndataset_available = pathlib.Path(DATA_ENV).exists()\nif dataset_available:\n    dsets = load_spr_bench(pathlib.Path(DATA_ENV))\nelse:\n    print(\"SPR_BENCH not found \u2013 generating synthetic data.\")\n\n    def synth_split(n):\n        shapes, colors = [\"\u25b2\", \"\u25cf\", \"\u25a0\"], [\"r\", \"g\", \"b\"]\n        seqs, labels = [], []\n        for _ in range(n):\n            seq = \" \".join(\n                np.random.choice(\n                    [s + c for s in shapes for c in colors],\n                    size=np.random.randint(3, 8),\n                )\n            )\n            seqs.append(seq)\n            labels.append(np.random.choice([\"A\", \"B\", \"C\"]))\n        return {\"sequence\": seqs, \"label\": labels}\n\n    dsets = DatasetDict()\n    for spl, n in zip([\"train\", \"dev\", \"test\"], [200, 50, 50]):\n        dsets[spl] = load_dataset(\n            \"json\", data_files={\"train\": synth_split(n)}, split=\"train\"\n        )\n\n# -------------  Vectorisation -------------\nvectorizer = CountVectorizer(token_pattern=r\"[^ ]+\")\nvectorizer.fit(dsets[\"train\"][\"sequence\"])\nvocab_size = len(vectorizer.vocabulary_)\n\n\ndef vec(seqs: List[str]):\n    return vectorizer.transform(seqs).toarray().astype(np.float32)\n\n\nX_train, X_val, X_test = map(\n    vec, [dsets[s][\"sequence\"] for s in [\"train\", \"dev\", \"test\"]]\n)\n\n# -------------  Label encoding -------------\nlabels = sorted(set(dsets[\"train\"][\"label\"]))\nlabel2id = {l: i for i, l in enumerate(labels)}\nid2label = {i: l for l, i in label2id.items()}\ny_train = np.array([label2id[l] for l in dsets[\"train\"][\"label\"]], np.int64)\ny_val = np.array([label2id[l] for l in dsets[\"dev\"][\"label\"]], np.int64)\ny_test = np.array([label2id[l] for l in dsets[\"test\"][\"label\"]], np.int64)\nnum_classes = len(labels)\n\n# -------------  DataLoaders -------------\nbatch_size = 64\ntrain_loader = DataLoader(\n    TensorDataset(torch.from_numpy(X_train), torch.from_numpy(y_train)),\n    batch_size=batch_size,\n    shuffle=True,\n)\nval_loader = DataLoader(\n    TensorDataset(torch.from_numpy(X_val), torch.from_numpy(y_val)),\n    batch_size=batch_size,\n)\n\n\n# -------------  Model definition -------------\nclass MLP(nn.Module):\n    def __init__(self, in_dim, n_classes):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(in_dim, 256), nn.ReLU(), nn.Linear(256, n_classes)\n        )\n\n    def forward(self, x):\n        return self.net(x)\n\n\n# -------------  Hyper-parameter sweep -------------\nweight_decay_values = [0.0, 1e-5, 1e-4, 1e-3, 1e-2]\nepochs = 5\ncriterion = nn.CrossEntropyLoss()\n\nfor wd in weight_decay_values:\n    print(f\"\\n=== Training with weight_decay={wd} ===\")\n    model = MLP(vocab_size, num_classes).to(device)\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-3, weight_decay=wd)\n\n    run_data = {\n        \"metrics\": {\"train\": [], \"val\": [], \"test\": {}},\n        \"losses\": {\"train\": [], \"val\": []},\n        \"predictions\": [],\n        \"ground_truth\": y_test.tolist(),\n        \"sequences\": dsets[\"test\"][\"sequence\"],\n        \"weight_decay\": wd,\n    }\n\n    for epoch in range(1, epochs + 1):\n        # --- training ---\n        model.train()\n        tr_loss = 0.0\n        for xb, yb in train_loader:\n            xb, yb = xb.to(device), yb.to(device)\n            optimizer.zero_grad()\n            loss = criterion(model(xb), yb)\n            loss.backward()\n            optimizer.step()\n            tr_loss += loss.item() * xb.size(0)\n        tr_loss /= len(train_loader.dataset)\n        run_data[\"losses\"][\"train\"].append(tr_loss)\n\n        # --- validation ---\n        model.eval()\n        val_loss, all_preds, all_tgts = 0.0, [], []\n        with torch.no_grad():\n            for xb, yb in val_loader:\n                xb, yb = xb.to(device), yb.to(device)\n                logits = model(xb)\n                loss = criterion(logits, yb)\n                val_loss += loss.item() * xb.size(0)\n                preds = logits.argmax(1).cpu().numpy()\n                all_preds.extend(preds)\n                all_tgts.extend(yb.cpu().numpy())\n        val_loss /= len(val_loader.dataset)\n        run_data[\"losses\"][\"val\"].append(val_loss)\n\n        seqs_val = dsets[\"dev\"][\"sequence\"]\n        acc = (np.array(all_preds) == np.array(all_tgts)).mean()\n        cwa = color_weighted_accuracy(seqs_val, all_tgts, all_preds)\n        swa = shape_weighted_accuracy(seqs_val, all_tgts, all_preds)\n        comp = complexity_weighted_accuracy(seqs_val, all_tgts, all_preds)\n        run_data[\"metrics\"][\"val\"].append(\n            {\"epoch\": epoch, \"acc\": acc, \"cwa\": cwa, \"swa\": swa, \"compwa\": comp}\n        )\n\n        print(\n            f\"Epoch {epoch}: train_loss={tr_loss:.4f} val_loss={val_loss:.4f} ACC={acc:.3f} CWA={cwa:.3f} SWA={swa:.3f} CompWA={comp:.3f}\"\n        )\n\n    # --- Test evaluation ---\n    with torch.no_grad():\n        logits = model(torch.from_numpy(X_test).to(device))\n        test_preds = logits.argmax(1).cpu().numpy()\n    test_acc = (test_preds == y_test).mean()\n    test_cwa = color_weighted_accuracy(dsets[\"test\"][\"sequence\"], y_test, test_preds)\n    test_swa = shape_weighted_accuracy(dsets[\"test\"][\"sequence\"], y_test, test_preds)\n    test_comp = complexity_weighted_accuracy(\n        dsets[\"test\"][\"sequence\"], y_test, test_preds\n    )\n    run_data[\"metrics\"][\"test\"] = {\n        \"acc\": test_acc,\n        \"cwa\": test_cwa,\n        \"swa\": test_swa,\n        \"compwa\": test_comp,\n    }\n    run_data[\"predictions\"] = test_preds.tolist()\n\n    print(\n        f\"Test: ACC={test_acc:.3f} CWA={test_cwa:.3f} SWA={test_swa:.3f} CompWA={test_comp:.3f}\"\n    )\n\n    # store run\n    experiment_data[\"weight_decay\"][\"SPR_BENCH\"][str(wd)] = run_data\n\n# -------------  Save everything -------------\nnp.save(\n    os.path.join(working_dir, \"experiment_data.npy\"), experiment_data, allow_pickle=True\n)\nprint(f\"\\nSaved all results to {os.path.join(working_dir,'experiment_data.npy')}\")\n"], "term_out": ["['Using device: cuda', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 20000 examples [00:00, 499610.37\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 5000 examples [00:00, 552332.69\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 10000 examples [00:00, 639180.74\nexamples/s]', '\\n', 'Vocabulary size: 16', '\\n', 'Number of classes: 2', '\\n',\n'Epoch 1: train_loss=0.4525  validation_loss=0.3239  ACC=0.878  CWA=0.876\nSWA=0.874  CompWA=0.872', '\\n', 'Epoch 2: train_loss=0.2553\nvalidation_loss=0.2173  ACC=0.940  CWA=0.938  SWA=0.936  CompWA=0.935', '\\n',\n'Epoch 3: train_loss=0.1987  validation_loss=0.1948  ACC=0.944  CWA=0.942\nSWA=0.940  CompWA=0.938', '\\n', 'Epoch 4: train_loss=0.1823\nvalidation_loss=0.1804  ACC=0.948  CWA=0.946  SWA=0.943  CompWA=0.942', '\\n',\n'Epoch 5: train_loss=0.1752  validation_loss=0.1759  ACC=0.948  CWA=0.947\nSWA=0.943  CompWA=0.942', '\\n', '\\nTest set \u2014  ACC=0.687  CWA=0.629  SWA=0.686\nCompWA=0.628', '\\n', 'Saved experiment data to /home/zxl240011/AI-Scientist-\nv2/experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/0-\nrun/process_ForkProcess-4/working/experiment_data.npy', '\\n', 'Execution time:\n17 seconds seconds (time limit is 30 minutes).']", "['\\rGenerating train split: 0 examples [00:00, ? examples/s]', '', '\\rGenerating\ntrain split: 20000 examples [00:00, 409064.70 examples/s]', '\\n', '\\rGenerating\ntrain split: 0 examples [00:00, ? examples/s]', '', '\\rGenerating train split:\n5000 examples [00:00, 509685.51 examples/s]', '\\n', '\\rGenerating train split: 0\nexamples [00:00, ? examples/s]', '', '\\rGenerating train split: 10000 examples\n[00:00, 672908.18 examples/s]', '\\n', '\\n=== Training with 5 epochs ===', '\\n',\n'Test  ACC=0.687  CWA=0.629  SWA=0.686 CompWA=0.628', '\\n', '\\n=== Training with\n10 epochs ===', '\\n', 'Test  ACC=0.687  CWA=0.629  SWA=0.686 CompWA=0.628',\n'\\n', '\\n=== Training with 20 epochs ===', '\\n', 'Test  ACC=0.687  CWA=0.629\nSWA=0.686 CompWA=0.628', '\\n', '\\n=== Training with 30 epochs ===', '\\n', 'Test\nACC=0.686  CWA=0.629  SWA=0.685 CompWA=0.628', '\\n', '\\nSaved results to\n/home/zxl240011/AI-Scientist-v2/experiments/2025-08-31_03-13-\n33_symbol_glyph_clustering_attempt_0/0-run/process_ForkProcess-\n6/working/experiment_data.npy', '\\n', 'Execution time: 51 seconds seconds (time\nlimit is 30 minutes).']", "['Running on', ' ', 'cuda', '\\n', '\\rGenerating train split: 0 examples [00:00,\n? examples/s]', '', '\\rGenerating train split: 20000 examples [00:00, 255344.65\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 5000 examples [00:00, 346848.82\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 10000 examples [00:00, 528742.66\nexamples/s]', '\\n', 'Vocabulary size:', ' ', '16', '\\n', '\\n=== Training with\nlearning rate = 1e-04 ===', '\\n', 'Epoch 1: train_loss=0.6334 val_loss=0.5682\nACC=0.762 CWA=0.755 SWA=0.755 CompWA=0.747', '\\n', 'Epoch 2: train_loss=0.5317\nval_loss=0.5054 ACC=0.777 CWA=0.771 SWA=0.771 CompWA=0.764', '\\n', 'Epoch 3:\ntrain_loss=0.4904 val_loss=0.4777 ACC=0.786 CWA=0.780 SWA=0.780 CompWA=0.774',\n'\\n', 'Epoch 4: train_loss=0.4667 val_loss=0.4564 ACC=0.801 CWA=0.797 SWA=0.797\nCompWA=0.792', '\\n', 'Epoch 5: train_loss=0.4451 val_loss=0.4347 ACC=0.813\nCWA=0.809 SWA=0.809 CompWA=0.805', '\\n', 'Test \u2014 ACC=0.645 CWA=0.605 SWA=0.645\nCompWA=0.606', '\\n', '\\n=== Training with learning rate = 3e-04 ===', '\\n',\n'Epoch 1: train_loss=0.5518 val_loss=0.4858 ACC=0.763 CWA=0.754 SWA=0.756\nCompWA=0.747', '\\n', 'Epoch 2: train_loss=0.4493 val_loss=0.4116 ACC=0.820\nCWA=0.815 SWA=0.816 CompWA=0.811', '\\n', 'Epoch 3: train_loss=0.3712\nval_loss=0.3318 ACC=0.876 CWA=0.874 SWA=0.872 CompWA=0.869', '\\n', 'Epoch 4:\ntrain_loss=0.3022 val_loss=0.2763 ACC=0.914 CWA=0.913 SWA=0.912 CompWA=0.912',\n'\\n', 'Epoch 5: train_loss=0.2579 val_loss=0.2452 ACC=0.922 CWA=0.922 SWA=0.920\nCompWA=0.919', '\\n', 'Test \u2014 ACC=0.674 CWA=0.620 SWA=0.674 CompWA=0.620', '\\n',\n'\\n=== Training with learning rate = 1e-03 ===', '\\n', 'Epoch 1:\ntrain_loss=0.4620 val_loss=0.3313 ACC=0.885 CWA=0.883 SWA=0.882 CompWA=0.880',\n'\\n', 'Epoch 2: train_loss=0.2568 val_loss=0.2156 ACC=0.943 CWA=0.942 SWA=0.939\nCompWA=0.938', '\\n', 'Epoch 3: train_loss=0.1999 val_loss=0.1958 ACC=0.945\nCWA=0.943 SWA=0.941 CompWA=0.939', '\\n', 'Epoch 4: train_loss=0.1831\nval_loss=0.1814 ACC=0.949 CWA=0.948 SWA=0.945 CompWA=0.943', '\\n', 'Epoch 5:\ntrain_loss=0.1759 val_loss=0.1761 ACC=0.949 CWA=0.947 SWA=0.944 CompWA=0.943',\n'\\n', 'Test \u2014 ACC=0.687 CWA=0.629 SWA=0.686 CompWA=0.629', '\\n', '\\n=== Training\nwith learning rate = 3e-03 ===', '\\n', 'Epoch 1: train_loss=0.3158\nval_loss=0.2000 ACC=0.944 CWA=0.942 SWA=0.939 CompWA=0.937', '\\n', 'Epoch 2:\ntrain_loss=0.1848 val_loss=0.1751 ACC=0.949 CWA=0.947 SWA=0.944 CompWA=0.943',\n'\\n', 'Epoch 3: train_loss=0.1717 val_loss=0.1773 ACC=0.948 CWA=0.946 SWA=0.943\nCompWA=0.942', '\\n', 'Epoch 4: train_loss=0.1686 val_loss=0.1672 ACC=0.949\nCWA=0.948 SWA=0.945 CompWA=0.943', '\\n', 'Epoch 5: train_loss=0.1662\nval_loss=0.1688 ACC=0.949 CWA=0.948 SWA=0.945 CompWA=0.943', '\\n', 'Test \u2014\nACC=0.687 CWA=0.629 SWA=0.686 CompWA=0.628', '\\n', 'Saved experiment data to', '\n', '/home/zxl240011/AI-Scientist-v2/experiments/2025-08-31_03-13-\n33_symbol_glyph_clustering_attempt_0/0-run/process_ForkProcess-\n7/working/experiment_data.npy', '\\n', 'Execution time: 13 seconds seconds (time\nlimit is 30 minutes).']", "['Using device: cuda', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 20000 examples [00:00, 310412.11\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 5000 examples [00:00, 516819.95\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 10000 examples [00:00, 315888.48\nexamples/s]', '\\n', 'Vocabulary size:', ' ', '16', '\\n', 'Classes:', ' ', '[0,\n1]', '\\n', '\\n=== Training with batch_size=16 ===', '\\n', 'Epoch 1: loss\n0.336/0.211 ACC 0.942 CWA 0.941 SWA 0.937 CompWA 0.936', '\\n', 'Epoch 2: loss\n0.190/0.182 ACC 0.948 CWA 0.947 SWA 0.944 CompWA 0.942', '\\n', 'Epoch 3: loss\n0.175/0.174 ACC 0.948 CWA 0.947 SWA 0.944 CompWA 0.942', '\\n', 'Epoch 4: loss\n0.169/0.171 ACC 0.949 CWA 0.947 SWA 0.944 CompWA 0.943', '\\n', 'Epoch 5: loss\n0.167/0.167 ACC 0.949 CWA 0.948 SWA 0.944 CompWA 0.943', '\\n', 'Test: ACC 0.687\nCWA 0.629 SWA 0.686 CompWA 0.628', '\\n', '\\n=== Training with batch_size=32\n===', '\\n', 'Epoch 1: loss 0.392/0.244 ACC 0.929 CWA 0.928 SWA 0.925 CompWA\n0.925', '\\n', 'Epoch 2: loss 0.210/0.194 ACC 0.947 CWA 0.946 SWA 0.943 CompWA\n0.941', '\\n', 'Epoch 3: loss 0.183/0.180 ACC 0.948 CWA 0.946 SWA 0.943 CompWA\n0.942', '\\n', 'Epoch 4: loss 0.174/0.175 ACC 0.949 CWA 0.948 SWA 0.945 CompWA\n0.943', '\\n', 'Epoch 5: loss 0.169/0.173 ACC 0.949 CWA 0.947 SWA 0.944 CompWA\n0.943', '\\n', 'Test: ACC 0.687 CWA 0.629 SWA 0.686 CompWA 0.628', '\\n', '\\n===\nTraining with batch_size=64 ===', '\\n', 'Epoch 1: loss 0.462/0.331 ACC 0.885 CWA\n0.883 SWA 0.882 CompWA 0.880', '\\n', 'Epoch 2: loss 0.257/0.216 ACC 0.943 CWA\n0.942 SWA 0.939 CompWA 0.938', '\\n', 'Epoch 3: loss 0.200/0.196 ACC 0.945 CWA\n0.943 SWA 0.941 CompWA 0.939', '\\n', 'Epoch 4: loss 0.183/0.181 ACC 0.949 CWA\n0.948 SWA 0.945 CompWA 0.943', '\\n', 'Epoch 5: loss 0.176/0.176 ACC 0.949 CWA\n0.947 SWA 0.944 CompWA 0.943', '\\n', 'Test: ACC 0.687 CWA 0.629 SWA 0.686 CompWA\n0.629', '\\n', '\\n=== Training with batch_size=128 ===', '\\n', 'Epoch 1: loss\n0.504/0.412 ACC 0.820 CWA 0.815 SWA 0.817 CompWA 0.812', '\\n', 'Epoch 2: loss\n0.332/0.267 ACC 0.915 CWA 0.915 SWA 0.913 CompWA 0.913', '\\n', 'Epoch 3: loss\n0.236/0.217 ACC 0.942 CWA 0.941 SWA 0.938 CompWA 0.936', '\\n', 'Epoch 4: loss\n0.204/0.198 ACC 0.946 CWA 0.945 SWA 0.942 CompWA 0.940', '\\n', 'Epoch 5: loss\n0.190/0.188 ACC 0.947 CWA 0.945 SWA 0.942 CompWA 0.941', '\\n', 'Test: ACC 0.688\nCWA 0.630 SWA 0.686 CompWA 0.629', '\\n', 'Saved experiment data to', ' ',\n'/home/zxl240011/AI-Scientist-v2/experiments/2025-08-31_03-13-\n33_symbol_glyph_clustering_attempt_0/0-run/process_ForkProcess-\n8/working/experiment_data.npy', '\\n', 'Execution time: 17 seconds seconds (time\nlimit is 30 minutes).']", "['Using device: cuda', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 20000 examples [00:00, 233030.48\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 5000 examples [00:00, 159898.75\nexamples/s]', '\\n', '\\rGenerating train split: 0 examples [00:00, ?\nexamples/s]', '', '\\rGenerating train split: 10000 examples [00:00, 270134.93\nexamples/s]', '\\n', '\\n=== Training with weight_decay=0.0 ===', '\\n', 'Epoch 1:\ntrain_loss=0.4525 val_loss=0.3239 ACC=0.878 CWA=0.876 SWA=0.874 CompWA=0.872',\n'\\n', 'Epoch 2: train_loss=0.2553 val_loss=0.2173 ACC=0.940 CWA=0.938 SWA=0.936\nCompWA=0.935', '\\n', 'Epoch 3: train_loss=0.1987 val_loss=0.1948 ACC=0.944\nCWA=0.942 SWA=0.940 CompWA=0.938', '\\n', 'Epoch 4: train_loss=0.1823\nval_loss=0.1804 ACC=0.948 CWA=0.946 SWA=0.943 CompWA=0.942', '\\n', 'Epoch 5:\ntrain_loss=0.1752 val_loss=0.1759 ACC=0.948 CWA=0.947 SWA=0.943 CompWA=0.942',\n'\\n', 'Test: ACC=0.687 CWA=0.629 SWA=0.686 CompWA=0.628', '\\n', '\\n=== Training\nwith weight_decay=1e-05 ===', '\\n', 'Epoch 1: train_loss=0.4517 val_loss=0.3180\nACC=0.890 CWA=0.889 SWA=0.887 CompWA=0.886', '\\n', 'Epoch 2: train_loss=0.2518\nval_loss=0.2157 ACC=0.939 CWA=0.938 SWA=0.935 CompWA=0.934', '\\n', 'Epoch 3:\ntrain_loss=0.1989 val_loss=0.1911 ACC=0.948 CWA=0.946 SWA=0.943 CompWA=0.942',\n'\\n', 'Epoch 4: train_loss=0.1821 val_loss=0.1812 ACC=0.948 CWA=0.947 SWA=0.944\nCompWA=0.942', '\\n', 'Epoch 5: train_loss=0.1751 val_loss=0.1783 ACC=0.948\nCWA=0.947 SWA=0.944 CompWA=0.942', '\\n', 'Test: ACC=0.687 CWA=0.629 SWA=0.686\nCompWA=0.628', '\\n', '\\n=== Training with weight_decay=0.0001 ===', '\\n', 'Epoch\n1: train_loss=0.4602 val_loss=0.3252 ACC=0.890 CWA=0.888 SWA=0.887\nCompWA=0.885', '\\n', 'Epoch 2: train_loss=0.2549 val_loss=0.2156 ACC=0.942\nCWA=0.941 SWA=0.938 CompWA=0.937', '\\n', 'Epoch 3: train_loss=0.2002\nval_loss=0.1955 ACC=0.945 CWA=0.943 SWA=0.941 CompWA=0.939', '\\n', 'Epoch 4:\ntrain_loss=0.1835 val_loss=0.1818 ACC=0.949 CWA=0.947 SWA=0.944 CompWA=0.943',\n'\\n', 'Epoch 5: train_loss=0.1765 val_loss=0.1767 ACC=0.949 CWA=0.947 SWA=0.944\nCompWA=0.943', '\\n', 'Test: ACC=0.687 CWA=0.629 SWA=0.686 CompWA=0.628', '\\n',\n'\\n=== Training with weight_decay=0.001 ===', '\\n', 'Epoch 1: train_loss=0.4484\nval_loss=0.3086 ACC=0.903 CWA=0.903 SWA=0.902 CompWA=0.902', '\\n', 'Epoch 2:\ntrain_loss=0.2490 val_loss=0.2146 ACC=0.941 CWA=0.940 SWA=0.937 CompWA=0.936',\n'\\n', 'Epoch 3: train_loss=0.2018 val_loss=0.1957 ACC=0.948 CWA=0.946 SWA=0.943\nCompWA=0.941', '\\n', 'Epoch 4: train_loss=0.1883 val_loss=0.1852 ACC=0.948\nCWA=0.946 SWA=0.943 CompWA=0.942', '\\n', 'Epoch 5: train_loss=0.1821\nval_loss=0.1826 ACC=0.948 CWA=0.947 SWA=0.943 CompWA=0.942', '\\n', 'Test:\nACC=0.687 CWA=0.629 SWA=0.686 CompWA=0.628', '\\n', '\\n=== Training with\nweight_decay=0.01 ===', '\\n', 'Epoch 1: train_loss=0.4717 val_loss=0.3525\nACC=0.862 CWA=0.859 SWA=0.860 CompWA=0.856', '\\n', 'Epoch 2: train_loss=0.3059\nval_loss=0.2759 ACC=0.922 CWA=0.921 SWA=0.921 CompWA=0.920', '\\n', 'Epoch 3:\ntrain_loss=0.2707 val_loss=0.2651 ACC=0.927 CWA=0.927 SWA=0.925 CompWA=0.924',\n'\\n', 'Epoch 4: train_loss=0.2638 val_loss=0.2571 ACC=0.931 CWA=0.930 SWA=0.929\nCompWA=0.928', '\\n', 'Epoch 5: train_loss=0.2590 val_loss=0.2569 ACC=0.933\nCWA=0.932 SWA=0.930 CompWA=0.929', '\\n', 'Test: ACC=0.678 CWA=0.622 SWA=0.678\nCompWA=0.622', '\\n', '\\nSaved all results to /home/zxl240011/AI-Scientist-\nv2/experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/0-\nrun/process_ForkProcess-9/working/experiment_data.npy', '\\n', 'Execution time:\n23 seconds seconds (time limit is 30 minutes).']"], "analysis": ["", "", "", "", ""], "exc_type": [null, null, null, null, null], "exc_info": [null, null, null, null, null], "exc_stack": [null, null, null, null, null], "exp_name": "0-run", "metrics": [{"metric_names": [{"metric_name": "training loss", "lower_is_better": true, "description": "The loss during training phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.1752, "best_value": 0.1752}]}, {"metric_name": "validation loss", "lower_is_better": true, "description": "The loss during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.1759, "best_value": 0.1759}]}, {"metric_name": "validation accuracy", "lower_is_better": false, "description": "The accuracy during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9482, "best_value": 0.9482}]}, {"metric_name": "validation color weighted accuracy", "lower_is_better": false, "description": "The color weighted accuracy during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9466, "best_value": 0.9466}]}, {"metric_name": "validation shape weighted accuracy", "lower_is_better": false, "description": "The shape weighted accuracy during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9435, "best_value": 0.9435}]}, {"metric_name": "validation complexity weighted accuracy", "lower_is_better": false, "description": "The complexity weighted accuracy during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9419, "best_value": 0.9419}]}, {"metric_name": "test accuracy", "lower_is_better": false, "description": "The accuracy during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6869, "best_value": 0.6869}]}, {"metric_name": "test color weighted accuracy", "lower_is_better": false, "description": "The color weighted accuracy during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6288, "best_value": 0.6288}]}, {"metric_name": "test shape weighted accuracy", "lower_is_better": false, "description": "The shape weighted accuracy during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6856, "best_value": 0.6856}]}, {"metric_name": "test complexity weighted accuracy", "lower_is_better": false, "description": "The complexity weighted accuracy during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6282, "best_value": 0.6282}]}]}, {"metric_names": [{"metric_name": "train loss", "lower_is_better": true, "description": "The loss value on the training dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.1769, "best_value": 0.1769}, {"dataset_name": "epochs_10", "final_value": 0.164, "best_value": 0.164}, {"dataset_name": "epochs_20", "final_value": 0.1561, "best_value": 0.1561}, {"dataset_name": "epochs_30", "final_value": 0.1499, "best_value": 0.1499}]}, {"metric_name": "validation loss", "lower_is_better": true, "description": "The loss value on the validation dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.1765, "best_value": 0.1765}, {"dataset_name": "epochs_10", "final_value": 0.169, "best_value": 0.169}, {"dataset_name": "epochs_20", "final_value": 0.1704, "best_value": 0.1704}, {"dataset_name": "epochs_30", "final_value": 0.1721, "best_value": 0.1721}]}, {"metric_name": "validation accuracy", "lower_is_better": false, "description": "The accuracy value on the validation dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.9486, "best_value": 0.9486}, {"dataset_name": "epochs_10", "final_value": 0.9492, "best_value": 0.9492}, {"dataset_name": "epochs_20", "final_value": 0.9492, "best_value": 0.9492}, {"dataset_name": "epochs_30", "final_value": 0.9494, "best_value": 0.9494}]}, {"metric_name": "validation CWA", "lower_is_better": false, "description": "The CWA value on the validation dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.947, "best_value": 0.947}, {"dataset_name": "epochs_10", "final_value": 0.9477, "best_value": 0.9477}, {"dataset_name": "epochs_20", "final_value": 0.9477, "best_value": 0.9477}, {"dataset_name": "epochs_30", "final_value": 0.9478, "best_value": 0.9478}]}, {"metric_name": "validation SWA", "lower_is_better": false, "description": "The SWA value on the validation dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.944, "best_value": 0.944}, {"dataset_name": "epochs_10", "final_value": 0.9447, "best_value": 0.9447}, {"dataset_name": "epochs_20", "final_value": 0.9447, "best_value": 0.9447}, {"dataset_name": "epochs_30", "final_value": 0.9449, "best_value": 0.9449}]}, {"metric_name": "validation CompWA", "lower_is_better": false, "description": "The CompWA value on the validation dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.9424, "best_value": 0.9424}, {"dataset_name": "epochs_10", "final_value": 0.9432, "best_value": 0.9432}, {"dataset_name": "epochs_20", "final_value": 0.9432, "best_value": 0.9432}, {"dataset_name": "epochs_30", "final_value": 0.9434, "best_value": 0.9434}]}, {"metric_name": "test accuracy", "lower_is_better": false, "description": "The accuracy value on the test dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.6868, "best_value": 0.6868}, {"dataset_name": "epochs_10", "final_value": 0.6871, "best_value": 0.6871}, {"dataset_name": "epochs_20", "final_value": 0.6871, "best_value": 0.6871}, {"dataset_name": "epochs_30", "final_value": 0.6865, "best_value": 0.6865}]}, {"metric_name": "test CWA", "lower_is_better": false, "description": "The CWA value on the test dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.6287, "best_value": 0.6287}, {"dataset_name": "epochs_10", "final_value": 0.629, "best_value": 0.629}, {"dataset_name": "epochs_20", "final_value": 0.629, "best_value": 0.629}, {"dataset_name": "epochs_30", "final_value": 0.6285, "best_value": 0.6285}]}, {"metric_name": "test SWA", "lower_is_better": false, "description": "The SWA value on the test dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.6855, "best_value": 0.6855}, {"dataset_name": "epochs_10", "final_value": 0.6858, "best_value": 0.6858}, {"dataset_name": "epochs_20", "final_value": 0.6859, "best_value": 0.6859}, {"dataset_name": "epochs_30", "final_value": 0.6853, "best_value": 0.6853}]}, {"metric_name": "test CompWA", "lower_is_better": false, "description": "The CompWA value on the test dataset.", "data": [{"dataset_name": "epochs_5", "final_value": 0.6281, "best_value": 0.6281}, {"dataset_name": "epochs_10", "final_value": 0.6284, "best_value": 0.6284}, {"dataset_name": "epochs_20", "final_value": 0.6284, "best_value": 0.6284}, {"dataset_name": "epochs_30", "final_value": 0.628, "best_value": 0.628}]}]}, {"metric_names": [{"metric_name": "training accuracy", "lower_is_better": false, "description": "The accuracy of the model on the training dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9483, "best_value": 0.9483}]}, {"metric_name": "training loss", "lower_is_better": true, "description": "The loss of the model on the training dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.1662, "best_value": 0.1662}]}, {"metric_name": "validation accuracy", "lower_is_better": false, "description": "The accuracy of the model on the validation dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9492, "best_value": 0.9492}]}, {"metric_name": "validation loss", "lower_is_better": true, "description": "The loss of the model on the validation dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.1688, "best_value": 0.1688}]}, {"metric_name": "test accuracy", "lower_is_better": false, "description": "The accuracy of the model on the test dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6872, "best_value": 0.6872}]}, {"metric_name": "test color-weighted accuracy", "lower_is_better": false, "description": "The color-weighted accuracy of the model on the test dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6292, "best_value": 0.6292}]}, {"metric_name": "test shape-weighted accuracy", "lower_is_better": false, "description": "The shape-weighted accuracy of the model on the test dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6859, "best_value": 0.6859}]}, {"metric_name": "test complexity-weighted accuracy", "lower_is_better": false, "description": "The complexity-weighted accuracy of the model on the test dataset.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6285, "best_value": 0.6285}]}]}, {"metric_names": [{"metric_name": "training loss", "lower_is_better": true, "description": "The loss value during training.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.167434, "best_value": 0.167434}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.169447, "best_value": 0.169447}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.175935, "best_value": 0.175935}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.189939, "best_value": 0.189939}]}, {"metric_name": "validation loss", "lower_is_better": true, "description": "The loss value during validation.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.166702, "best_value": 0.166702}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.173312, "best_value": 0.173312}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.176074, "best_value": 0.176074}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.188454, "best_value": 0.188454}]}, {"metric_name": "validation accuracy", "lower_is_better": false, "description": "The accuracy during validation.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.949, "best_value": 0.949}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.9492, "best_value": 0.9492}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.9492, "best_value": 0.9492}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.9466, "best_value": 0.9466}]}, {"metric_name": "validation color weighted accuracy", "lower_is_better": false, "description": "The color-weighted accuracy during validation.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.947532, "best_value": 0.947532}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.947654, "best_value": 0.947654}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.947654, "best_value": 0.947654}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.945092, "best_value": 0.945092}]}, {"metric_name": "validation shape weighted accuracy", "lower_is_better": false, "description": "The shape-weighted accuracy during validation.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.944483, "best_value": 0.944483}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.944658, "best_value": 0.944658}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.944658, "best_value": 0.944658}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.942158, "best_value": 0.942158}]}, {"metric_name": "validation complexity weighted accuracy", "lower_is_better": false, "description": "The complexity-weighted accuracy during validation.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.943051, "best_value": 0.943051}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.943157, "best_value": 0.943157}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.943157, "best_value": 0.943157}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.940675, "best_value": 0.940675}]}, {"metric_name": "test accuracy", "lower_is_better": false, "description": "The accuracy during testing.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.6868, "best_value": 0.6868}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.6871, "best_value": 0.6871}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.6872, "best_value": 0.6872}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.6875, "best_value": 0.6875}]}, {"metric_name": "test color weighted accuracy", "lower_is_better": false, "description": "The color-weighted accuracy during testing.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.628779, "best_value": 0.628779}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.628961, "best_value": 0.628961}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.629204, "best_value": 0.629204}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.629842, "best_value": 0.629842}]}, {"metric_name": "test shape weighted accuracy", "lower_is_better": false, "description": "The shape-weighted accuracy during testing.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.685582, "best_value": 0.685582}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.685843, "best_value": 0.685843}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.685901, "best_value": 0.685901}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.686132, "best_value": 0.686132}]}, {"metric_name": "test complexity weighted accuracy", "lower_is_better": false, "description": "The complexity-weighted accuracy during testing.", "data": [{"dataset_name": "SPR_BENCH (batch_size=16)", "final_value": 0.6282, "best_value": 0.6282}, {"dataset_name": "SPR_BENCH (batch_size=32)", "final_value": 0.628359, "best_value": 0.628359}, {"dataset_name": "SPR_BENCH (batch_size=64)", "final_value": 0.628544, "best_value": 0.628544}, {"dataset_name": "SPR_BENCH (batch_size=128)", "final_value": 0.629081, "best_value": 0.629081}]}]}, {"metric_names": [{"metric_name": "training loss", "lower_is_better": true, "description": "Loss calculated during training phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.1751, "best_value": 0.1751}]}, {"metric_name": "validation loss", "lower_is_better": true, "description": "Loss calculated during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.1759, "best_value": 0.1759}]}, {"metric_name": "validation accuracy", "lower_is_better": false, "description": "Accuracy achieved during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.949, "best_value": 0.949}]}, {"metric_name": "validation color weighted accuracy", "lower_is_better": false, "description": "Color-weighted accuracy achieved during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9474, "best_value": 0.9474}]}, {"metric_name": "validation shape weighted accuracy", "lower_is_better": false, "description": "Shape-weighted accuracy achieved during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9444, "best_value": 0.9444}]}, {"metric_name": "validation complexity weighted accuracy", "lower_is_better": false, "description": "Complexity-weighted accuracy achieved during validation phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.9429, "best_value": 0.9429}]}, {"metric_name": "test accuracy", "lower_is_better": false, "description": "Accuracy achieved during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6871, "best_value": 0.6871}]}, {"metric_name": "test color weighted accuracy", "lower_is_better": false, "description": "Color-weighted accuracy achieved during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6291, "best_value": 0.6291}]}, {"metric_name": "test shape weighted accuracy", "lower_is_better": false, "description": "Shape-weighted accuracy achieved during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6858, "best_value": 0.6858}]}, {"metric_name": "test complexity weighted accuracy", "lower_is_better": false, "description": "Complexity-weighted accuracy achieved during testing phase.", "data": [{"dataset_name": "SPR_BENCH", "final_value": 0.6284, "best_value": 0.6284}]}]}], "is_best_node": [false, false, true, false, false], "plots": [["../../logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_loss_curve.png", "../../logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_validation_metrics.png", "../../logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_confusion_matrix.png"], ["../../logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_5.png", "../../logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_10.png", "../../logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_20.png", "../../logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_30.png", "../../logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_test_metrics_vs_epochs.png"], ["../../logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_loss_curves.png", "../../logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_accuracy_curves.png", "../../logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_test_metrics.png"], ["../../logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_loss_curves_bs.png", "../../logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_val_accuracy_bs.png", "../../logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_test_metrics_bs.png"], ["../../logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_loss_curves_all_wd.png", "../../logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_val_accuracy_all_wd.png", "../../logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_test_accuracy_bar.png", "../../logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_test_weighted_accuracies_bar.png"]], "plot_paths": [["experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_loss_curve.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_validation_metrics.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_confusion_matrix.png"], ["experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_5.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_10.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_20.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_30.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_test_metrics_vs_epochs.png"], ["experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_loss_curves.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_accuracy_curves.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_test_metrics.png"], ["experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_loss_curves_bs.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_val_accuracy_bs.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_test_metrics_bs.png"], ["experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_loss_curves_all_wd.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_val_accuracy_all_wd.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_test_accuracy_bar.png", "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_test_weighted_accuracies_bar.png"]], "plot_analyses": [[{"analysis": "The plot shows the training and validation loss over five epochs. Both losses decrease steadily, indicating that the model is learning effectively and generalizing well without significant overfitting. The validation loss closely follows the training loss, suggesting a good balance between training and validation performance.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_loss_curve.png"}, {"analysis": "This plot depicts the evolution of various metrics over epochs, including ACC, CWA, SWA, and CompWA. All metrics improve significantly after the first epoch and plateau after the second epoch, achieving values around 0.94-0.95. This indicates that the model quickly converges to a high level of performance and maintains stable results across metrics.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_validation_metrics.png"}, {"analysis": "The confusion matrix for the test dataset reveals that the model performs well overall but has a noticeable number of misclassifications. Specifically, it correctly predicts 3173 true negatives and 3696 true positives, while misclassifying 1811 false positives and 1320 false negatives. The imbalance between false positives and false negatives could indicate areas for further optimization, such as adjusting the decision threshold or refining the model's sensitivity to certain features.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_f8da8c8eea714565ac0c580cee281ea8_proc_1619822/SPR_BENCH_confusion_matrix.png"}], [{"analysis": "This plot shows the training and validation loss over 5 epochs. The training loss decreases rapidly, and the validation loss follows a similar trend, indicating effective learning in early epochs. The close alignment of the two curves suggests minimal overfitting at this stage.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_5.png"}, {"analysis": "This plot extends the training and validation loss curves to 10 epochs. The loss reduction stabilizes after about 5 epochs, with the validation loss slightly higher than the training loss, indicating possible overfitting starting to emerge.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_10.png"}, {"analysis": "This plot shows the loss curves over 20 epochs. While the training loss continues to decrease, the validation loss stabilizes and starts to increase slightly after around 15 epochs, suggesting overfitting becomes more pronounced with extended training.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_20.png"}, {"analysis": "The loss curves for 30 epochs highlight the overfitting trend more clearly. While the training loss continues to decline, the validation loss exhibits an upward trend after about 20 epochs, indicating diminishing returns on training duration.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_loss_epochs_30.png"}, {"analysis": "This plot tracks test metrics (ACC, CWA, SWA, CompWA) over different training epochs. The metrics stabilize early, with minimal improvement beyond 10 epochs. The ACC and SWA hover around 0.69, while CWA and CompWA remain lower, suggesting limited gains from prolonged training.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_ce8a65e4871745bdba290cb3fbd4d488_proc_1624790/SPR_BENCH_test_metrics_vs_epochs.png"}], [{"analysis": "The first plot shows the loss curves for training and validation across different learning rates. The learning rate of 3e-03 achieves the fastest convergence for both training and validation losses, stabilizing around epoch 3. In contrast, lower learning rates (1e-04 and 3e-04) show slower convergence and higher final losses, indicating underfitting. The learning rate of 1e-03 also performs well, but its validation loss stabilizes slightly higher than 3e-03, suggesting 3e-03 might be the optimal choice for this dataset and model.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_loss_curves.png"}, {"analysis": "The second plot illustrates the accuracy trends for training and validation across different learning rates. The learning rate of 3e-03 achieves the highest accuracy for both training and validation, plateauing around 95% by epoch 3. The learning rate of 1e-03 follows closely, while 1e-04 and 3e-04 lag behind in terms of maximum accuracy achieved. This indicates that higher learning rates, particularly 3e-03, enable the model to learn the patterns more effectively in fewer epochs.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_accuracy_curves.png"}, {"analysis": "The third plot compares test metrics (overall accuracy, color-weighted accuracy, shape-weighted accuracy, and a composite metric) across learning rates. All learning rates perform similarly, but 3e-03 slightly outperforms others in most metrics, particularly in color-weighted accuracy and shape-weighted accuracy. This reinforces the conclusion that 3e-03 is the most effective learning rate for this experiment.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_aa4fbdd9a41749f2bcf3e3a4a838f829_proc_1624791/SPR_BENCH_test_metrics.png"}], [{"analysis": "The first plot shows the loss curves for training and validation across different batch sizes (16, 32, 64, and 128). Smaller batch sizes (16 and 32) exhibit a lower overall loss and better convergence compared to larger batch sizes (64 and 128). The larger batch sizes show higher initial loss and slower convergence, but by the final epoch, all configurations achieve similar loss values. This suggests that smaller batch sizes might be more effective in capturing finer details during training, leading to faster convergence.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_loss_curves_bs.png"}, {"analysis": "The second plot illustrates validation accuracy over epochs for various batch sizes. Smaller batch sizes (16 and 32) achieve higher accuracy earlier in the training process, whereas larger batch sizes (64 and 128) take longer to reach comparable accuracy levels. However, by the final epoch, all batch sizes converge to similar accuracy values, indicating that while smaller batch sizes provide faster learning, the ultimate performance is consistent across batch sizes.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_val_accuracy_bs.png"}, {"analysis": "The third plot compares test metrics (Accuracy, CWA, SWA, and COMPWA) for different batch sizes. All metrics show consistent performance across batch sizes, with no significant differences observed. This indicates that batch size does not have a strong impact on the final test performance, suggesting that the model generalizes well regardless of batch size. The scores for CWA and SWA are close to the SOTA benchmarks, indicating that the proposed approach is competitive.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_055d446b13664bca97c455bccb0fc189_proc_1624792/SPR_BENCH_test_metrics_bs.png"}], [{"analysis": "The first plot shows the training and validation cross-entropy loss for different weight decay values over epochs. The training loss decreases steadily for all weight decay values, with minimal variation observed between the different settings. However, the validation loss curves indicate that weight decay values such as 0.001 and 0.01 stabilize better after epoch 2, while higher weight decay values (e.g., 0.01) exhibit slightly higher validation loss, suggesting potential over-regularization.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_loss_curves_all_wd.png"}, {"analysis": "The second plot illustrates validation accuracy across epochs for different weight decay values. All configurations achieve high accuracy (>94%) by epoch 3, with minimal differences between weight decay values. However, weight decay of 0.001 shows a slightly slower convergence compared to others, indicating that it might not be the optimal choice for rapid convergence.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_val_accuracy_all_wd.png"}, {"analysis": "The third plot evaluates test accuracy across different weight decay values. The results show minimal variation, with all configurations achieving similar test accuracy (~70%). This indicates that weight decay does not significantly impact the overall test performance in this experiment.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_test_accuracy_bar.png"}, {"analysis": "The fourth plot compares the test weighted accuracies (CWA, SWA, and CompWA) for different weight decay values. The results are consistent across all configurations, with CWA and SWA showing slightly higher values compared to CompWA. This indicates that the model's performance on weighted metrics is robust to changes in weight decay.", "plot_path": "experiments/2025-08-31_03-13-33_symbol_glyph_clustering_attempt_0/logs/0-run/experiment_results/experiment_d3300a9124d246279255ab852c9c4f76_proc_1624793/SPR_BENCH_test_weighted_accuracies_bar.png"}]], "vlm_feedback_summary": ["The plots provide insights into the model's training dynamics, metric\nconvergence, and test performance. The results demonstrate effective learning\nand high validation accuracy, with room for improvement in reducing\nmisclassifications as shown in the confusion matrix.", "The training and validation loss plots reveal effective learning in early\nepochs, but overfitting becomes evident with extended training beyond 10 epochs.\nTest metrics stabilize early, showing marginal improvements with additional\ntraining. Prolonged training yields little benefit and may even degrade\ngeneralization performance.", "The plots indicate that a learning rate of 3e-03 provides the best performance,\nachieving faster convergence, higher accuracy, and better test metrics compared\nto other learning rates. Lower learning rates show slower convergence and\nsuboptimal results, suggesting underfitting.", "The analysis highlights that smaller batch sizes (16 and 32) lead to faster\nconvergence during training and validation but do not significantly impact the\nfinal test performance. The metrics (CWA and SWA) are close to the SOTA\nbenchmarks, suggesting that the proposed symbolic glyph clustering approach is\npromising.", "The plots demonstrate that weight decay has a limited impact on both validation\nand test performance, with all configurations achieving similar results. While\nweight decay of 0.001 and 0.01 stabilize validation loss better, they do not\nsignificantly affect test accuracy or weighted metrics. The model appears robust\nacross different hyperparameter choices in this stage."], "exec_time": [17.441168308258057, 51.35195326805115, 13.410884857177734, 17.48549723625183, 23.976950883865356], "exec_time_feedback": ["", "", "", "", ""], "datasets_successfully_tested": [["[\"SPR_BENCH\"]"], ["[\"SPR_BENCH\"]"], ["[\"SPR_BENCH\"]"], ["[\"SPR_BENCH\"]"], ["[\"SPR_BENCH\"]"]], "plot_code": ["import matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# ------------------------------------------------------------------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\ntry:\n    experiment_data = np.load(\n        os.path.join(working_dir, \"experiment_data.npy\"), allow_pickle=True\n    ).item()\nexcept Exception as e:\n    print(f\"Error loading experiment data: {e}\")\n    experiment_data = {}\n\nds = \"SPR_BENCH\"\nif ds not in experiment_data:\n    print(f\"Dataset {ds} not found in experiment_data.\")\n    exit()\n\n\n# ------------------------------------------------------------------\n# Helper to fetch arrays safely\ndef get_losses(split):\n    return np.array(experiment_data[ds][\"losses\"].get(split, []), dtype=float)\n\n\ndef get_metric_over_epochs(key):\n    return np.array(\n        [m[key] for m in experiment_data[ds][\"metrics\"][\"val\"]], dtype=float\n    )\n\n\n# ------------------------------------------------------------------\n# 1) Loss curves ----------------------------------------------------\ntry:\n    train_loss = get_losses(\"train\")\n    val_loss = get_losses(\"val\")\n    epochs = np.arange(1, len(train_loss) + 1)\n\n    plt.figure()\n    plt.plot(epochs, train_loss, label=\"Train Loss\")\n    plt.plot(epochs, val_loss, label=\"Validation Loss\")\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Cross-Entropy Loss\")\n    plt.title(\"SPR_BENCH Training vs Validation Loss\")\n    plt.legend()\n    plt.tight_layout()\n    fname = os.path.join(working_dir, \"SPR_BENCH_loss_curve.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error creating loss curve: {e}\")\n    plt.close()\n\n# ------------------------------------------------------------------\n# 2) Validation metrics curves -------------------------------------\ntry:\n    acc = get_metric_over_epochs(\"acc\")\n    cwa = get_metric_over_epochs(\"cwa\")\n    swa = get_metric_over_epochs(\"swa\")\n    comp = get_metric_over_epochs(\"compwa\")\n    epochs = np.arange(1, len(acc) + 1)\n\n    plt.figure()\n    for y, lbl in zip([acc, cwa, swa, comp], [\"ACC\", \"CWA\", \"SWA\", \"CompWA\"]):\n        plt.plot(epochs, y, marker=\"o\", label=lbl)\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Metric Value\")\n    plt.title(\"SPR_BENCH Validation Metrics Over Epochs\")\n    plt.legend()\n    plt.tight_layout()\n    fname = os.path.join(working_dir, \"SPR_BENCH_validation_metrics.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error creating validation metrics plot: {e}\")\n    plt.close()\n\n# ------------------------------------------------------------------\n# 3) Confusion matrix (test) ---------------------------------------\ntry:\n    y_true = np.array(experiment_data[ds][\"ground_truth\"], dtype=int)\n    y_pred = np.array(experiment_data[ds][\"predictions\"], dtype=int)\n    n_cls = max(y_true.max(), y_pred.max()) + 1\n    cm = np.zeros((n_cls, n_cls), dtype=int)\n    for t, p in zip(y_true, y_pred):\n        cm[t, p] += 1\n\n    plt.figure()\n    im = plt.imshow(cm, cmap=\"Blues\")\n    plt.colorbar(im, fraction=0.046, pad=0.04)\n    plt.title(\"SPR_BENCH Confusion Matrix (Test)\")\n    plt.xlabel(\"Predicted\")\n    plt.ylabel(\"True\")\n    tick_labels = list(range(n_cls))\n    plt.xticks(tick_labels)\n    plt.yticks(tick_labels)\n    # annotate cells\n    for i in range(n_cls):\n        for j in range(n_cls):\n            plt.text(j, i, cm[i, j], ha=\"center\", va=\"center\", color=\"black\")\n    plt.tight_layout()\n    fname = os.path.join(working_dir, \"SPR_BENCH_confusion_matrix.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error creating confusion matrix plot: {e}\")\n    plt.close()\n\n# ------------------------------------------------------------------\n# Print final test metrics -----------------------------------------\ntest_metrics = experiment_data[ds][\"metrics\"].get(\"test\", {})\nif test_metrics:\n    print(\"Test metrics:\")\n    for k, v in test_metrics.items():\n        print(f\"  {k}: {v:.4f}\")\n", "import matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# ensure working directory\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\n\n# load experiment data\ntry:\n    experiment_data = np.load(\n        os.path.join(working_dir, \"experiment_data.npy\"), allow_pickle=True\n    ).item()\nexcept Exception as e:\n    print(f\"Error loading experiment data: {e}\")\n    experiment_data = {}\n\n# navigate to SPR_BENCH sweep results\nspr_results = experiment_data.get(\"epoch_tuning\", {}).get(\"SPR_BENCH\", {})\n\n# ------------- print test metrics table -------------\nprint(\"\\n=== SPR_BENCH test metrics ===\")\nheader = \"{:10s} {:>6s} {:>6s} {:>6s} {:>8s}\"\nprint(header.format(\"run\", \"ACC\", \"CWA\", \"SWA\", \"CompWA\"))\nfor run, data in spr_results.items():\n    tm = data[\"metrics\"][\"test\"]\n    print(\n        header.format(\n            run,\n            f\"{tm['acc']:.3f}\",\n            f\"{tm['cwa']:.3f}\",\n            f\"{tm['swa']:.3f}\",\n            f\"{tm['compwa']:.3f}\",\n        )\n    )\n\n# ------------- per-run loss curves -------------\nfor run, data in spr_results.items():\n    try:\n        tl = data[\"losses\"][\"train\"]\n        vl = data[\"losses\"][\"val\"]\n        epochs = list(range(1, len(tl) + 1))\n\n        plt.figure()\n        plt.plot(epochs, tl, label=\"Train Loss\")\n        plt.plot(epochs, vl, label=\"Validation Loss\")\n        plt.xlabel(\"Epoch\")\n        plt.ylabel(\"Cross-Entropy Loss\")\n        plt.title(f\"SPR_BENCH Training vs Validation Loss ({run})\")\n        plt.legend()\n        fname = os.path.join(working_dir, f\"SPR_BENCH_loss_{run}.png\")\n        plt.savefig(fname)\n        plt.close()\n    except Exception as e:\n        print(f\"Error plotting loss for {run}: {e}\")\n        plt.close()\n\n# ------------- summary metrics vs epochs -------------\ntry:\n    epoch_counts, accs, cwas, swas, compwas = [], [], [], [], []\n    for run in sorted(spr_results.keys(), key=lambda x: int(x.split(\"_\")[-1])):\n        ep = int(run.split(\"_\")[-1])\n        tm = spr_results[run][\"metrics\"][\"test\"]\n        epoch_counts.append(ep)\n        accs.append(tm[\"acc\"])\n        cwas.append(tm[\"cwa\"])\n        swas.append(tm[\"swa\"])\n        compwas.append(tm[\"compwa\"])\n\n    plt.figure()\n    for vals, lab in zip([accs, cwas, swas, compwas], [\"ACC\", \"CWA\", \"SWA\", \"CompWA\"]):\n        plt.plot(epoch_counts, vals, marker=\"o\", label=lab)\n    plt.xlabel(\"Training Epochs\")\n    plt.ylabel(\"Metric Value\")\n    plt.title(\"SPR_BENCH Test Metrics vs Training Epochs\")\n    plt.legend()\n    fname = os.path.join(working_dir, \"SPR_BENCH_test_metrics_vs_epochs.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error plotting summary metrics: {e}\")\n    plt.close()\n", "import matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\n\ntry:\n    exp = np.load(\n        os.path.join(working_dir, \"experiment_data.npy\"), allow_pickle=True\n    ).item()\n    runs = exp[\"learning_rate\"][\"SPR_BENCH\"][\"runs\"]\nexcept Exception as e:\n    print(f\"Error loading experiment data: {e}\")\n    runs = []\n\n\n# Helper to get epochs\ndef get_epochs(run):\n    return np.arange(1, len(run[\"losses\"][\"train\"]) + 1)\n\n\n# --------- Figure 1 : Loss curves -------------\ntry:\n    plt.figure()\n    for run in runs:\n        epochs = get_epochs(run)\n        plt.plot(\n            epochs,\n            run[\"losses\"][\"train\"],\n            label=f\"lr={run['lr']:.0e} train\",\n            linestyle=\"-\",\n        )\n        plt.plot(\n            epochs,\n            run[\"losses\"][\"val\"],\n            label=f\"lr={run['lr']:.0e} val\",\n            linestyle=\"--\",\n        )\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Cross-Entropy Loss\")\n    plt.title(\"SPR_BENCH \u2013 Loss Curves\\nLeft: Train, Right: Validation\")\n    plt.legend()\n    fname = os.path.join(working_dir, \"SPR_BENCH_loss_curves.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error creating loss curves: {e}\")\n    plt.close()\n\n# --------- Figure 2 : Accuracy curves ----------\ntry:\n    plt.figure()\n    for run in runs:\n        epochs = get_epochs(run)\n        tr_acc = [m[\"acc\"] for m in run[\"metrics\"][\"train\"]]\n        val_acc = [m[\"acc\"] for m in run[\"metrics\"][\"val\"]]\n        plt.plot(epochs, tr_acc, label=f\"lr={run['lr']:.0e} train\", linestyle=\"-\")\n        plt.plot(epochs, val_acc, label=f\"lr={run['lr']:.0e} val\", linestyle=\"--\")\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(\"SPR_BENCH \u2013 Accuracy Curves\\nTrain vs Validation\")\n    plt.legend()\n    fname = os.path.join(working_dir, \"SPR_BENCH_accuracy_curves.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error creating accuracy curves: {e}\")\n    plt.close()\n\n# --------- Figure 3 : Test metrics bar chart ----\ntry:\n    metrics = [\"acc\", \"cwa\", \"swa\", \"compwa\"]\n    x = np.arange(len(metrics))\n    width = 0.15\n    plt.figure()\n    for i, run in enumerate(runs):\n        vals = [run[\"metrics\"][\"test\"][m] for m in metrics]\n        plt.bar(x + i * width, vals, width, label=f\"lr={run['lr']:.0e}\")\n    plt.xticks(x + width * (len(runs) - 1) / 2, metrics)\n    plt.ylim(0, 1)\n    plt.ylabel(\"Score\")\n    plt.title(\"SPR_BENCH \u2013 Test Metrics by Learning Rate\")\n    plt.legend()\n    fname = os.path.join(working_dir, \"SPR_BENCH_test_metrics.png\")\n    plt.savefig(fname)\n    plt.close()\nexcept Exception as e:\n    print(f\"Error creating test metrics plot: {e}\")\n    plt.close()\n", "import matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# ---------- load data ----------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\n\ntry:\n    experiment_data = np.load(\n        os.path.join(working_dir, \"experiment_data.npy\"), allow_pickle=True\n    ).item()\nexcept Exception as e:\n    print(f\"Error loading experiment data: {e}\")\n    experiment_data = {}\n\nruns = experiment_data.get(\"batch_size\", {}).get(\"SPR_BENCH\", {}).get(\"runs\", [])\n\n# helper to avoid crashes if no data\nif not runs:\n    print(\"No runs found in experiment_data; nothing to plot.\")\nelse:\n    # ---------- PLOT 1: Loss curves ----------\n    try:\n        plt.figure(figsize=(7, 5))\n        for run in runs:\n            bs = run[\"batch_size\"]\n            epochs = range(1, len(run[\"losses\"][\"train\"]) + 1)\n            plt.plot(epochs, run[\"losses\"][\"train\"], label=f\"Train bs={bs}\")\n            plt.plot(epochs, run[\"losses\"][\"val\"], linestyle=\"--\", label=f\"Val bs={bs}\")\n        plt.title(\"SPR_BENCH Loss Curves (Train vs Val)\")\n        plt.xlabel(\"Epoch\")\n        plt.ylabel(\"Cross-Entropy Loss\")\n        plt.legend()\n        out = os.path.join(working_dir, \"SPR_BENCH_loss_curves_bs.png\")\n        plt.savefig(out)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating loss curve plot: {e}\")\n        plt.close()\n\n    # ---------- PLOT 2: Validation accuracy per epoch ----------\n    try:\n        plt.figure(figsize=(7, 5))\n        for run in runs:\n            bs = run[\"batch_size\"]\n            accs = [ep[\"acc\"] for ep in run[\"metrics\"][\"val\"]]\n            plt.plot(range(1, len(accs) + 1), accs, label=f\"bs={bs}\")\n        plt.title(\"SPR_BENCH Validation Accuracy per Epoch\")\n        plt.xlabel(\"Epoch\")\n        plt.ylabel(\"Accuracy\")\n        plt.legend()\n        out = os.path.join(working_dir, \"SPR_BENCH_val_accuracy_bs.png\")\n        plt.savefig(out)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating val accuracy plot: {e}\")\n        plt.close()\n\n    # ---------- PLOT 3: Final test metrics ----------\n    try:\n        metrics = [\"acc\", \"cwa\", \"swa\", \"compwa\"]\n        x = np.arange(len(runs))\n        width = 0.18\n        plt.figure(figsize=(8, 5))\n        for i, m in enumerate(metrics):\n            vals = [run[\"metrics\"][\"test\"][m] for run in runs]\n            plt.bar(x + i * width, vals, width=width, label=m.upper())\n        plt.xticks(x + width * 1.5, [f\"bs={run['batch_size']}\" for run in runs])\n        plt.ylabel(\"Score\")\n        plt.title(\"SPR_BENCH Test Metrics vs Batch Size\")\n        plt.legend()\n        out = os.path.join(working_dir, \"SPR_BENCH_test_metrics_bs.png\")\n        plt.savefig(out)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating test metrics plot: {e}\")\n        plt.close()\n\n    # ---------- print summary ----------\n    print(\"\\nFinal Test Metrics\")\n    for run in runs:\n        bs = run[\"batch_size\"]\n        m = run[\"metrics\"][\"test\"]\n        print(\n            f\"bs={bs:3}: ACC={m['acc']:.3f}  CWA={m['cwa']:.3f}  SWA={m['swa']:.3f}  CompWA={m['compwa']:.3f}\"\n        )\n", "import matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\n# --- set up ---\nworking_dir = os.path.join(os.getcwd(), \"working\")\nos.makedirs(working_dir, exist_ok=True)\n\n# --- load experiment data ---\ntry:\n    exp_path = os.path.join(working_dir, \"experiment_data.npy\")\n    experiment_data = np.load(exp_path, allow_pickle=True).item()\nexcept Exception as e:\n    print(f\"Error loading experiment data: {e}\")\n    experiment_data = None\n\nif experiment_data:\n    try:\n        runs = experiment_data[\"weight_decay\"][\"SPR_BENCH\"]\n    except Exception as e:\n        print(f\"Error extracting runs: {e}\")\n        runs = {}\n\n    # Pre-collect per-run arrays\n    wd_vals, train_losses, val_losses, val_accs = [], [], [], []\n    test_accs, test_cwa, test_swa, test_comp = [], [], [], []\n\n    for wd, data in runs.items():\n        wd_vals.append(float(wd))\n        train_losses.append(data[\"losses\"][\"train\"])\n        val_losses.append(data[\"losses\"][\"val\"])\n        val_accs.append([m[\"acc\"] for m in data[\"metrics\"][\"val\"]])\n        t = data[\"metrics\"][\"test\"]\n        test_accs.append(t[\"acc\"])\n        test_cwa.append(t[\"cwa\"])\n        test_swa.append(t[\"swa\"])\n        test_comp.append(t[\"compwa\"])\n\n    epochs = np.arange(1, len(train_losses[0]) + 1)\n\n    # -------- Plot 1: loss curves --------\n    try:\n        plt.figure()\n        for tl, vl, wd in zip(train_losses, val_losses, wd_vals):\n            plt.plot(epochs, tl, label=f\"train wd={wd}\")\n            plt.plot(epochs, vl, \"--\", label=f\"val wd={wd}\")\n        plt.xlabel(\"Epoch\")\n        plt.ylabel(\"Cross-entropy loss\")\n        plt.title(\"SPR_BENCH: Train vs. Val Loss (all weight_decay)\")\n        plt.legend()\n        fname = os.path.join(working_dir, \"SPR_BENCH_loss_curves_all_wd.png\")\n        plt.savefig(fname)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating loss curves: {e}\")\n        plt.close()\n\n    # -------- Plot 2: validation accuracy --------\n    try:\n        plt.figure()\n        for va, wd in zip(val_accs, wd_vals):\n            plt.plot(epochs, va, label=f\"wd={wd}\")\n        plt.xlabel(\"Epoch\")\n        plt.ylabel(\"Accuracy\")\n        plt.title(\"SPR_BENCH: Validation Accuracy over Epochs\")\n        plt.legend()\n        fname = os.path.join(working_dir, \"SPR_BENCH_val_accuracy_all_wd.png\")\n        plt.savefig(fname)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating val accuracy plot: {e}\")\n        plt.close()\n\n    # -------- Plot 3: test accuracy bar chart --------\n    try:\n        plt.figure()\n        idx = np.arange(len(wd_vals))\n        plt.bar(idx, test_accs, color=\"skyblue\")\n        plt.xticks(idx, wd_vals)\n        plt.ylabel(\"Accuracy\")\n        plt.title(\"SPR_BENCH: Test Accuracy vs. weight_decay\")\n        plt.xlabel(\"weight_decay\")\n        fname = os.path.join(working_dir, \"SPR_BENCH_test_accuracy_bar.png\")\n        plt.savefig(fname)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating test accuracy bar: {e}\")\n        plt.close()\n\n    # -------- Plot 4: weighted accuracies bar chart --------\n    try:\n        plt.figure()\n        width = 0.2\n        idx = np.arange(len(wd_vals))\n        plt.bar(idx - width, test_cwa, width, label=\"CWA\")\n        plt.bar(idx, test_swa, width, label=\"SWA\")\n        plt.bar(idx + width, test_comp, width, label=\"CompWA\")\n        plt.xticks(idx, wd_vals)\n        plt.ylabel(\"Weighted Accuracy\")\n        plt.title(\"SPR_BENCH: Test Weighted Accuracies vs. weight_decay\")\n        plt.xlabel(\"weight_decay\")\n        plt.legend()\n        fname = os.path.join(working_dir, \"SPR_BENCH_test_weighted_accuracies_bar.png\")\n        plt.savefig(fname)\n        plt.close()\n    except Exception as e:\n        print(f\"Error creating weighted acc bar: {e}\")\n        plt.close()\n"], "plot_plan": ["The script will load experiment_data.npy from the working directory, ensure the folder exists, and then generate three key plots. First, it will draw a line chart comparing training and validation losses over the recorded epochs. Second, it will plot four validation metrics (ACC, CWA, SWA, CompWA) on one figure so trends can be inspected together. Third, using test\u2010set predictions and ground-truth labels, it will compute a confusion matrix and visualise it with imshow, adding class labels on both axes and annotating cell counts. Each plot is wrapped in its own try-except block, saved with descriptive filenames, and the figure is always closed. After plotting, the code prints out the final test metrics stored in the file so users can cross-check values against the visualisations. All plotting uses only basic matplotlib and respects the requirement of at most five figures. The code is concise and self-contained.", "We first load the saved numpy file, recover the nested dictionary and print a concise table of test-set metrics for every epoch configuration so users can eyeball the sweep results.  \nFor visual inspection we generate at most five figures: one summary plot that shows how the four test metrics (ACC, CWA, SWA, CompWA) change with the number of training epochs, and one loss curve (train vs validation) for each of the four individual runs (epochs_5, 10, 20, 30).  \nAll plots use basic matplotlib, are wrapped in their own try-except blocks, carry clear titles, are saved into the prescribed working_dir with descriptive file names, and every figure is explicitly closed.  \nOnly data found in experiment_data.npy are accessed\u2014no synthetic values are fabricated.  \nWe respect the \u201c\u22645 figure\u201d rule by plotting loss curves once for each run and using a single joint figure for sweep metrics.  \nThe code starts with the mandated imports and creates working_dir if it is missing.  \nFinally, after plotting, it prints the test metrics dictionary for each epoch setting so that an external evaluator (or the user) can quickly compare performance.", "We load experiment_data.npy, extract all runs under SPR_BENCH, and collect per-epoch train/validation losses and accuracies together with final test metrics.  \nFigure 1 shows training and validation loss curves for every learning-rate sweep, enabling quick comparison of convergence behaviour.  \nFigure 2 plots training and validation accuracy curves for the same runs, letting us observe generalisation gaps.  \nFigure 3 summarises the final test performance (ACC, CWA, SWA, CompWA) across learning rates with a grouped bar-chart, highlighting which lr works best on each metric.  \nAll figures are saved in working_dir with descriptive names (e.g. \u201cSPR_BENCH_loss_curves.png\u201d).  \nEvery plotting step is wrapped in its own try-except block to avoid a single failure stopping the rest, and each figure is always closed after saving.  \nOnly information present in experiment_data.npy is used; no synthetic values are introduced.  \nTitles clearly mention the dataset and the plot type, and subtitles distinguish curves (e.g. \u201cTrain vs Validation\u201d).  \nAt most three figures are produced, satisfying the 5-figure limit.", "We load experiment_data.npy, fetch the list of runs stored under the SPR_BENCH batch-size sweep, and collect per-epoch losses/accuracies as well as the final test metrics for every batch size. Three concise visualizations are produced: (1) combined train/validation loss curves for each batch size, (2) validation accuracy curves per epoch, and (3) a grouped bar chart summarising the final test metrics (ACC, CWA, SWA, CompWA) across batch sizes. Each figure is wrapped in an independent try-except block, saved into working_dir with descriptive names, and closed immediately after saving to prevent resource leakage. Only information present in experiment_data.npy is used; no synthetic values are introduced. The script also prints a small table of the final test metrics so they can be inspected in the log. At most three figures are generated\u2014well within the \u201c\u22645 figures\u201d guideline. All code starts with the required matplotlib/numpy/os imports and creates working_dir if necessary, following all specified style and robustness conventions. Finally, figures are titled clearly, for example \u201cSPR_BENCH Loss Curves (Train vs Val)\u201d.", "We load the saved experiment_data.npy, extract losses, validation metrics, and final test metrics for each weight-decay run, then create up to four basic matplotlib figures: (1) train vs. validation loss curves over epochs for all weight-decay values, (2) validation accuracy curves, (3) bar chart of final test accuracies, and (4) grouped bar chart of the three weighted accuracies (CWA, SWA, CompWA).  Each figure is wrapped in its own try-except block, includes clear titles/subtitles mentioning \u201cSPR_BENCH\u201d, is saved into working_dir with descriptive names, and is closed afterward.  No values are fabricated\u2014everything is read directly from experiment_data.  Only a maximum of four figures (<5) are produced, satisfying the interval requirement since there are just five epochs.  If the .npy file is missing or malformed the script reports the error but continues cleanly.  The code follows the provided boilerplate: imports, working_dir creation, data loading, plotting inside try-except, and figure closure.  Running the script will leave four .png files in the working directory and print nothing else unless errors arise."], "ablation_name": [null, null, null, null, null], "hyperparam_name": [null, "epochs", "learning_rate", "batch_size", "weight_decay"], "is_seed_node": [false, false, false, false, false], "is_seed_agg_node": [false, false, false, false, false], "parse_metrics_plan": ["Below is a small utility that immediately loads the saved NumPy file, extracts\nthe losses and accuracies recorded during training, picks the final training\nloss, the best (lowest) validation loss, the best (highest) validation\naccuracies, and the final test metrics, and prints them clearly for every\ndataset stored in the file.", "The script will load the `experiment_data.npy` from the working directory,\niterate over every saved run (e.g., \u201cepochs_5\u201d, \u201cepochs_10\u201d, \u2026) inside the SPR-\nBENCH experiments, and print the last training/validation losses, the best\n(highest-accuracy) validation metrics, and the final test metrics with explicit\nmetric names. All code executes immediately at import time\u2014no `if __name__ ==\n'__main__'` guard is used.", "The script will load the saved NumPy dictionary, iterate over every dataset\ncontained in it (e.g., \u201cSPR_BENCH\u201d), and scan all learning-rate runs.   For each\nrun it grabs the last\u2010epoch training / validation metrics and the single test\nmetrics, tracking the best (max for accuracies, min for losses) encountered\nacross runs.   After finishing a dataset, it prints the dataset name followed by\nclearly labelled lines reporting the best value for each metric.   Everything\nexecutes immediately at import time; no special entry point or plotting code is\nused.", "The script will load the serialized dictionary from experiment_data.npy,\nnavigate to the \u201cruns\u201d list for the SPR_BENCH dataset, and iterate over each run\n(one per batch-size).   For every run it prints the dataset name together with\nthe batch size, then reports the final training loss, the minimum validation\nloss, the best validation accuracies (plain, color-weighted, shape-weighted,\ncomplexity-weighted), and finally the test counterparts that were stored after\ntraining.   The code executes immediately at import time and keeps everything at\nthe top level, satisfying all structural constraints.", "The script will load the saved experiment_data.npy from the working directory,\ntraverse every weight-decay run stored under the dataset key (here \u201cSPR_BENCH\u201d),\ncollect every recorded metric across epochs, and then print the single best\n(i.e., highest for accuracies / weighted accuracies, lowest for losses) value\nobserved. The output prints the dataset name first and then each metric name\nfollowed by its best value, using explicit labels such as \u201cvalidation accuracy\u201d\nor \u201ctraining loss\u201d as required. No plots are created and the code executes\nimmediately at import time."], "parse_metrics_code": ["import os\nimport numpy as np\n\n# ------------------------------------------------------------------\n# Locate and load the experiment data\n# ------------------------------------------------------------------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nfile_path = os.path.join(working_dir, \"experiment_data.npy\")\nexperiment_data = np.load(file_path, allow_pickle=True).item()\n\n# ------------------------------------------------------------------\n# Iterate over each dataset and report metrics\n# ------------------------------------------------------------------\nfor dataset_name, ds in experiment_data.items():\n    print(dataset_name)  # dataset header\n\n    # ----------------- losses -----------------\n    train_losses = ds[\"losses\"][\"train\"]\n    val_losses = ds[\"losses\"][\"val\"]\n\n    if train_losses:\n        print(f\"final training loss: {train_losses[-1]:.4f}\")\n    if val_losses:\n        best_val_loss = min(val_losses)\n        print(f\"best validation loss: {best_val_loss:.4f}\")\n\n    # ----------------- validation metrics -----------------\n    val_metrics = ds[\"metrics\"].get(\"val\", [])\n    if val_metrics:\n        # choose the epoch with the highest validation accuracy\n        best_by_acc = max(val_metrics, key=lambda x: x.get(\"acc\", -np.inf))\n        print(f\"best validation accuracy: {best_by_acc['acc']:.4f}\")\n        print(f\"best validation color weighted accuracy: {best_by_acc['cwa']:.4f}\")\n        print(f\"best validation shape weighted accuracy: {best_by_acc['swa']:.4f}\")\n        print(\n            f\"best validation complexity weighted accuracy: {best_by_acc['compwa']:.4f}\"\n        )\n\n    # ----------------- test metrics -----------------\n    test_metrics = ds[\"metrics\"].get(\"test\")\n    if test_metrics:\n        print(f\"test accuracy: {test_metrics['acc']:.4f}\")\n        print(f\"test color weighted accuracy: {test_metrics['cwa']:.4f}\")\n        print(f\"test shape weighted accuracy: {test_metrics['swa']:.4f}\")\n        print(f\"test complexity weighted accuracy: {test_metrics['compwa']:.4f}\")\n\n    # separate datasets visually\n    print()\n", "import os\nimport numpy as np\n\n# ---------- locate and load result file ----------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nfile_path = os.path.join(working_dir, \"experiment_data.npy\")\nexperiment_data = np.load(file_path, allow_pickle=True).item()\n\n# ---------- navigate the nested dictionary ----------\nfor bench_name, runs in experiment_data.get(\"epoch_tuning\", {}).items():\n    # bench_name is expected to be \"SPR_BENCH\"\n    for run_name, run_data in runs.items():\n        print(f\"\\nDataset: {run_name}\")  # dataset name first\n\n        # ---------- losses ----------\n        losses = run_data.get(\"losses\", {})\n        if losses:\n            final_train_loss = (\n                losses.get(\"train\", [])[-1] if losses.get(\"train\") else None\n            )\n            final_val_loss = losses.get(\"val\", [])[-1] if losses.get(\"val\") else None\n            if final_train_loss is not None:\n                print(f\"final train loss: {final_train_loss:.4f}\")\n            if final_val_loss is not None:\n                print(f\"final validation loss: {final_val_loss:.4f}\")\n\n        # ---------- validation metrics (choose best by accuracy) ----------\n        val_metrics_list = run_data.get(\"metrics\", {}).get(\"val\", [])\n        if val_metrics_list:\n            best_val = max(val_metrics_list, key=lambda m: m.get(\"acc\", -1))\n            print(f\"best validation accuracy: {best_val['acc']:.4f}\")\n            print(f\"best validation CWA: {best_val['cwa']:.4f}\")\n            print(f\"best validation SWA: {best_val['swa']:.4f}\")\n            print(f\"best validation CompWA: {best_val['compwa']:.4f}\")\n\n        # ---------- test metrics ----------\n        test_metrics = run_data.get(\"metrics\", {}).get(\"test\", {})\n        if test_metrics:\n            print(f\"test accuracy: {test_metrics.get('acc', 0):.4f}\")\n            print(f\"test CWA: {test_metrics.get('cwa', 0):.4f}\")\n            print(f\"test SWA: {test_metrics.get('swa', 0):.4f}\")\n            print(f\"test CompWA: {test_metrics.get('compwa', 0):.4f}\")\n", "import os\nimport numpy as np\n\n# -------------------- load --------------------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nexp_path = os.path.join(working_dir, \"experiment_data.npy\")\nexperiment_data = np.load(exp_path, allow_pickle=True).item()\n\n\n# ------------------ helpers -------------------\ndef update_best(best_val, new_val, higher_is_better=True):\n    \"\"\"Return the better of two values according to the comparison rule.\"\"\"\n    if best_val is None:\n        return new_val\n    if higher_is_better:\n        return new_val if new_val > best_val else best_val\n    # lower is better\n    return new_val if new_val < best_val else best_val\n\n\n# --------------- extract & print ---------------\nfor dataset_name, ds_info in experiment_data[\"learning_rate\"].items():\n    runs = ds_info[\"runs\"]\n\n    # initialise bests\n    best_train_acc = best_train_loss = None\n    best_val_acc = best_val_loss = None\n    best_test_acc = best_test_cwa = None\n    best_test_swa = best_test_compwa = None\n\n    for run in runs:\n        # last epoch stats\n        train_acc = run[\"metrics\"][\"train\"][-1][\"acc\"]\n        train_loss = run[\"losses\"][\"train\"][-1]\n        val_acc = run[\"metrics\"][\"val\"][-1][\"acc\"]\n        val_loss = run[\"losses\"][\"val\"][-1]\n\n        # test stats\n        test_metrics = run[\"metrics\"][\"test\"]\n        test_acc = test_metrics[\"acc\"]\n        test_cwa = test_metrics[\"cwa\"]\n        test_swa = test_metrics[\"swa\"]\n        test_compwa = test_metrics[\"compwa\"]\n\n        # keep bests\n        best_train_acc = update_best(best_train_acc, train_acc, True)\n        best_train_loss = update_best(best_train_loss, train_loss, False)\n        best_val_acc = update_best(best_val_acc, val_acc, True)\n        best_val_loss = update_best(best_val_loss, val_loss, False)\n\n        best_test_acc = update_best(best_test_acc, test_acc, True)\n        best_test_cwa = update_best(best_test_cwa, test_cwa, True)\n        best_test_swa = update_best(best_test_swa, test_swa, True)\n        best_test_compwa = update_best(best_test_compwa, test_compwa, True)\n\n    # -------- print results --------\n    print(f\"Dataset: {dataset_name}\")\n    print(f\"best training accuracy: {best_train_acc:.4f}\")\n    print(f\"best training loss: {best_train_loss:.4f}\")\n    print(f\"best validation accuracy: {best_val_acc:.4f}\")\n    print(f\"best validation loss: {best_val_loss:.4f}\")\n    print(f\"best test accuracy: {best_test_acc:.4f}\")\n    print(f\"best test color-weighted accuracy: {best_test_cwa:.4f}\")\n    print(f\"best test shape-weighted accuracy: {best_test_swa:.4f}\")\n    print(f\"best test complexity-weighted accuracy: {best_test_compwa:.4f}\")\n", "import os\nimport numpy as np\n\n# ---------- load ----------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nfile_path = os.path.join(working_dir, \"experiment_data.npy\")\nexperiment_data = np.load(file_path, allow_pickle=True).item()\n\n# ---------- extract & print ----------\nfor dataset_name, dataset_info in experiment_data[\"batch_size\"].items():\n    runs = dataset_info[\"runs\"]\n    for run in runs:\n        bs = run[\"batch_size\"]\n        print(f\"{dataset_name} (batch_size={bs})\")\n\n        # training & validation losses\n        final_train_loss = run[\"losses\"][\"train\"][-1]\n        best_val_loss = min(run[\"losses\"][\"val\"])\n        print(f\"final training loss: {final_train_loss:.6f}\")\n        print(f\"best validation loss: {best_val_loss:.6f}\")\n\n        # validation metrics (pick the best value observed over epochs)\n        val_metrics = run[\"metrics\"][\"val\"]\n        best_val_acc = max(m[\"acc\"] for m in val_metrics)\n        best_val_cwa = max(m[\"cwa\"] for m in val_metrics)\n        best_val_swa = max(m[\"swa\"] for m in val_metrics)\n        best_val_compwa = max(m[\"compwa\"] for m in val_metrics)\n\n        print(f\"best validation accuracy: {best_val_acc:.6f}\")\n        print(f\"best validation color weighted accuracy: {best_val_cwa:.6f}\")\n        print(f\"best validation shape weighted accuracy: {best_val_swa:.6f}\")\n        print(f\"best validation complexity weighted accuracy: {best_val_compwa:.6f}\")\n\n        # test metrics (already final in record)\n        test_metrics = run[\"metrics\"][\"test\"]\n        print(f\"test accuracy: {test_metrics['acc']:.6f}\")\n        print(f\"test color weighted accuracy: {test_metrics['cwa']:.6f}\")\n        print(f\"test shape weighted accuracy: {test_metrics['swa']:.6f}\")\n        print(f\"test complexity weighted accuracy: {test_metrics['compwa']:.6f}\")\n        print()  # blank line between runs\n", "import os\nimport numpy as np\n\n# ---------- Locate and load the saved results ----------\nworking_dir = os.path.join(os.getcwd(), \"working\")\nfile_path = os.path.join(working_dir, \"experiment_data.npy\")\nexperiment_data = np.load(file_path, allow_pickle=True).item()\n\n\n# ---------- Helper to update best values ----------\ndef update_best(current_best, candidate, maximize=True):\n    \"\"\"Return the better of two values given a direction.\"\"\"\n    if current_best is None:\n        return candidate\n    return max(current_best, candidate) if maximize else min(current_best, candidate)\n\n\n# ---------- Iterate over datasets and compute best metrics ----------\nfor dataset_name, runs in experiment_data[\"weight_decay\"].items():\n    # Initialise holders for best values\n    best_train_loss = None\n    best_val_loss = None\n    best_val_acc = None\n    best_val_cwa = None\n    best_val_swa = None\n    best_val_compwa = None\n    best_test_acc = None\n    best_test_cwa = None\n    best_test_swa = None\n    best_test_compwa = None\n\n    # Traverse every weight-decay run\n    for run_key, run_data in runs.items():\n        # -------- Training & validation losses (lists per epoch) --------\n        train_losses = run_data[\"losses\"][\"train\"]\n        val_losses = run_data[\"losses\"][\"val\"]\n\n        if train_losses:  # safeguard\n            best_train_loss = update_best(\n                best_train_loss, min(train_losses), maximize=False\n            )\n        if val_losses:\n            best_val_loss = update_best(best_val_loss, min(val_losses), maximize=False)\n\n        # -------- Validation metrics (list of dicts per epoch) --------\n        for epoch_metrics in run_data[\"metrics\"][\"val\"]:\n            best_val_acc = update_best(best_val_acc, epoch_metrics[\"acc\"])\n            best_val_cwa = update_best(best_val_cwa, epoch_metrics[\"cwa\"])\n            best_val_swa = update_best(best_val_swa, epoch_metrics[\"swa\"])\n            best_val_compwa = update_best(best_val_compwa, epoch_metrics[\"compwa\"])\n\n        # -------- Test metrics (single dict) --------\n        test_metrics = run_data[\"metrics\"][\"test\"]\n        best_test_acc = update_best(best_test_acc, test_metrics[\"acc\"])\n        best_test_cwa = update_best(best_test_cwa, test_metrics[\"cwa\"])\n        best_test_swa = update_best(best_test_swa, test_metrics[\"swa\"])\n        best_test_compwa = update_best(best_test_compwa, test_metrics[\"compwa\"])\n\n    # ---------- Print the consolidated best results ----------\n    print(dataset_name)\n    if best_train_loss is not None:\n        print(f\"training loss: {best_train_loss:.4f}\")\n    if best_val_loss is not None:\n        print(f\"validation loss: {best_val_loss:.4f}\")\n    if best_val_acc is not None:\n        print(f\"validation accuracy: {best_val_acc:.4f}\")\n        print(f\"validation color weighted accuracy: {best_val_cwa:.4f}\")\n        print(f\"validation shape weighted accuracy: {best_val_swa:.4f}\")\n        print(f\"validation complexity weighted accuracy: {best_val_compwa:.4f}\")\n    if best_test_acc is not None:\n        print(f\"test accuracy: {best_test_acc:.4f}\")\n        print(f\"test color weighted accuracy: {best_test_cwa:.4f}\")\n        print(f\"test shape weighted accuracy: {best_test_swa:.4f}\")\n        print(f\"test complexity weighted accuracy: {best_test_compwa:.4f}\")\n"], "parse_term_out": ["['SPR_BENCH', '\\n', 'final training loss: 0.1752', '\\n', 'best validation loss:\n0.1759', '\\n', 'best validation accuracy: 0.9482', '\\n', 'best validation color\nweighted accuracy: 0.9466', '\\n', 'best validation shape weighted accuracy:\n0.9435', '\\n', 'best validation complexity weighted accuracy: 0.9419', '\\n',\n'test accuracy: 0.6869', '\\n', 'test color weighted accuracy: 0.6288', '\\n',\n'test shape weighted accuracy: 0.6856', '\\n', 'test complexity weighted\naccuracy: 0.6282', '\\n', '\\n', 'Execution time: a moment seconds (time limit is\n30 minutes).']", "['\\nDataset: epochs_5', '\\n', 'final train loss: 0.1769', '\\n', 'final\nvalidation loss: 0.1765', '\\n', 'best validation accuracy: 0.9486', '\\n', 'best\nvalidation CWA: 0.9470', '\\n', 'best validation SWA: 0.9440', '\\n', 'best\nvalidation CompWA: 0.9424', '\\n', 'test accuracy: 0.6868', '\\n', 'test CWA:\n0.6287', '\\n', 'test SWA: 0.6855', '\\n', 'test CompWA: 0.6281', '\\n',\n'\\nDataset: epochs_10', '\\n', 'final train loss: 0.1640', '\\n', 'final\nvalidation loss: 0.1690', '\\n', 'best validation accuracy: 0.9492', '\\n', 'best\nvalidation CWA: 0.9477', '\\n', 'best validation SWA: 0.9447', '\\n', 'best\nvalidation CompWA: 0.9432', '\\n', 'test accuracy: 0.6871', '\\n', 'test CWA:\n0.6290', '\\n', 'test SWA: 0.6858', '\\n', 'test CompWA: 0.6284', '\\n',\n'\\nDataset: epochs_20', '\\n', 'final train loss: 0.1561', '\\n', 'final\nvalidation loss: 0.1704', '\\n', 'best validation accuracy: 0.9492', '\\n', 'best\nvalidation CWA: 0.9477', '\\n', 'best validation SWA: 0.9447', '\\n', 'best\nvalidation CompWA: 0.9432', '\\n', 'test accuracy: 0.6871', '\\n', 'test CWA:\n0.6290', '\\n', 'test SWA: 0.6859', '\\n', 'test CompWA: 0.6284', '\\n',\n'\\nDataset: epochs_30', '\\n', 'final train loss: 0.1499', '\\n', 'final\nvalidation loss: 0.1721', '\\n', 'best validation accuracy: 0.9494', '\\n', 'best\nvalidation CWA: 0.9478', '\\n', 'best validation SWA: 0.9449', '\\n', 'best\nvalidation CompWA: 0.9434', '\\n', 'test accuracy: 0.6865', '\\n', 'test CWA:\n0.6285', '\\n', 'test SWA: 0.6853', '\\n', 'test CompWA: 0.6280', '\\n', 'Execution\ntime: a moment seconds (time limit is 30 minutes).']", "['Dataset: SPR_BENCH', '\\n', 'best training accuracy: 0.9483', '\\n', 'best\ntraining loss: 0.1662', '\\n', 'best validation accuracy: 0.9492', '\\n', 'best\nvalidation loss: 0.1688', '\\n', 'best test accuracy: 0.6872', '\\n', 'best test\ncolor-weighted accuracy: 0.6292', '\\n', 'best test shape-weighted accuracy:\n0.6859', '\\n', 'best test complexity-weighted accuracy: 0.6285', '\\n',\n'Execution time: a moment seconds (time limit is 30 minutes).']", "['SPR_BENCH (batch_size=16)', '\\n', 'final training loss: 0.167434', '\\n', 'best\nvalidation loss: 0.166702', '\\n', 'best validation accuracy: 0.949000', '\\n',\n'best validation color weighted accuracy: 0.947532', '\\n', 'best validation\nshape weighted accuracy: 0.944483', '\\n', 'best validation complexity weighted\naccuracy: 0.943051', '\\n', 'test accuracy: 0.686800', '\\n', 'test color weighted\naccuracy: 0.628779', '\\n', 'test shape weighted accuracy: 0.685582', '\\n', 'test\ncomplexity weighted accuracy: 0.628200', '\\n', '\\n', 'SPR_BENCH\n(batch_size=32)', '\\n', 'final training loss: 0.169447', '\\n', 'best validation\nloss: 0.173312', '\\n', 'best validation accuracy: 0.949200', '\\n', 'best\nvalidation color weighted accuracy: 0.947654', '\\n', 'best validation shape\nweighted accuracy: 0.944658', '\\n', 'best validation complexity weighted\naccuracy: 0.943157', '\\n', 'test accuracy: 0.687100', '\\n', 'test color weighted\naccuracy: 0.628961', '\\n', 'test shape weighted accuracy: 0.685843', '\\n', 'test\ncomplexity weighted accuracy: 0.628359', '\\n', '\\n', 'SPR_BENCH\n(batch_size=64)', '\\n', 'final training loss: 0.175935', '\\n', 'best validation\nloss: 0.176074', '\\n', 'best validation accuracy: 0.949200', '\\n', 'best\nvalidation color weighted accuracy: 0.947654', '\\n', 'best validation shape\nweighted accuracy: 0.944658', '\\n', 'best validation complexity weighted\naccuracy: 0.943157', '\\n', 'test accuracy: 0.687200', '\\n', 'test color weighted\naccuracy: 0.629204', '\\n', 'test shape weighted accuracy: 0.685901', '\\n', 'test\ncomplexity weighted accuracy: 0.628544', '\\n', '\\n', 'SPR_BENCH\n(batch_size=128)', '\\n', 'final training loss: 0.189939', '\\n', 'best validation\nloss: 0.188454', '\\n', 'best validation accuracy: 0.946600', '\\n', 'best\nvalidation color weighted accuracy: 0.945092', '\\n', 'best validation shape\nweighted accuracy: 0.942158', '\\n', 'best validation complexity weighted\naccuracy: 0.940675', '\\n', 'test accuracy: 0.687500', '\\n', 'test color weighted\naccuracy: 0.629842', '\\n', 'test shape weighted accuracy: 0.686132', '\\n', 'test\ncomplexity weighted accuracy: 0.629081', '\\n', '\\n', 'Execution time: a moment\nseconds (time limit is 30 minutes).']", "['SPR_BENCH', '\\n', 'training loss: 0.1751', '\\n', 'validation loss: 0.1759',\n'\\n', 'validation accuracy: 0.9490', '\\n', 'validation color weighted accuracy:\n0.9474', '\\n', 'validation shape weighted accuracy: 0.9444', '\\n', 'validation\ncomplexity weighted accuracy: 0.9429', '\\n', 'test accuracy: 0.6871', '\\n',\n'test color weighted accuracy: 0.6291', '\\n', 'test shape weighted accuracy:\n0.6858', '\\n', 'test complexity weighted accuracy: 0.6284', '\\n', 'Execution\ntime: a moment seconds (time limit is 30 minutes).']"], "parse_exc_type": [null, null, null, null, null], "parse_exc_info": [null, null, null, null, null], "parse_exc_stack": [null, null, null, null, null], "completed_stages": ["Stage_1", "Stage_2"]};

// Add log directory path and stage info to the tree data
treeStructData.log_dir_path = window.location.pathname.split('/').slice(0, -1).join('/');
treeStructData.current_stage = window.location.pathname.includes('stage_')
  ? window.location.pathname.split('stage_')[1].split('/')[0]
  : 'Stage_1';

// Initialize background color
window.bgColCurrent = bgCol;

// Function to set background color that can be called from the console
function setBackgroundColor(color) {
  // Update the global color
  updateBackgroundColor(color);

  // Refresh the current sketch to apply the new background color
  if (currentStage) {
    startSketch(currentStage);
  }
}

// Load all stage data and initialize the visualization
loadAllStageData(treeStructData);

    </script>
    <title>AI Scientist-v2 Visualization</title>
    <style>
      body,
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background-color: #ffffff;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }
      #canvas-container {
        position: absolute;
        left: 0;
        top: 0;
        width: 40vw;
        height: 100vh;
        background-color: inherit;
        padding-top: 40px;
      }
      canvas {
        float: left;
        height: 100vh;
        width: 100vw;
      }
      #text-container {
        float: right;
        height: 100vh;
        width: 50vw;
        background-color: #282c34;
        overflow: auto;
      }
      #plan {
        /* border-left: 2px solid #282c34; */
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
      }
      #plot_plan {
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
        white-space: pre-wrap;
      }
      #exec_time_feedback {
        margin-top: 20px;
        padding: 10px;
        background-color: #282c34;
        border-left: 3px solid #ff5555;
        color: #f2f0e7;
      }
      #exec_time {
        margin-top: 20px;
        padding: 10px;
        background-color: #282c34;
        border-left: 3px solid #ff5555;
        color: #f2f0e7;
      }
      #exc_info {
        margin-top: 20px;
        padding: 10px;
        background-color: #2c1f1f;
        border-left: 3px solid #ff5555;
        color: #f2f0e7;
      }
      #metrics {
        margin-top: 20px;
        padding: 10px;
        background-color: #282c34;
        color: #f2f0e7;
      }
      #vlm_feedback {
        margin-top: 20px;
        padding: 10px;
        background-color: #1f2c2f;
        color: #f2f0e7;
        border-left: 3px solid #55ff55;
      }
      #vlm_feedback p {
        margin: 0.5em 0;
        white-space: pre-wrap;
      }
      .datasets_successfully_tested {
        margin-top: 20px;
        padding: 10px;
        background-color: #282c34;
        color: #f2f0e7;
        border-left: 3px solid #55ff55;
      }
      .plots-container {
        float: right;
        width: 50vw;
        padding: 1rem;
        background-color: #282c34;
        margin-top: 1rem;
      }

      .plot-item {
        flex: 1 1 300px;
        max-width: 100%;
        margin-bottom: 1rem;
        white-space: pre-wrap;
      }

      .plot-item img {
        width: 100%;
        height: auto;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        display: block;
      }

      .metric-group {
        margin-bottom: 20px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .metric-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
      }

      .metric-table th,
      .metric-table td {
        padding: 8px;
        text-align: left;
        border: 1px solid #ddd;
      }

      .metric-table th {
        background-color: #363b44;
      }

      /* Styles for tabs */
      .tabs-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 49vw;
        background-color: #000000;
        z-index: 10;
        display: flex;
        padding: 0;
      }

      .tab {
        cursor: pointer;
        padding: 10px 15px;
        background-color: #333;
        color: #f2f0e7;
        border: none;
        outline: none;
        transition: background-color 0.3s;
        flex: 1;
        text-align: center;
      }

      .tab:hover {
        background-color: #444;
      }

      .tab.active {
        background-color: #4c76af;
        font-weight: bold;
      }

      .tab.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background-color: #282c34;
      }

      .tab-content {
        display: none;
        padding-top: 40px; /* Space for tabs */
      }

      .tab-content.active {
        display: block;
      }

      .stage-info {
        padding: 10px;
        background-color: #282c34;
        color: #f2f0e7;
        margin-bottom: 10px;
        font-size: 0.9em;
      }

      .stage-status {
        display: inline-block;
        padding: 3px 6px;
        border-radius: 3px;
        margin-left: 8px;
        font-size: 0.8em;
      }

      .stage-status.completed {
        background-color: #4caf50;
      }

      .stage-status.in-progress {
        background-color: #2196f3;
      }

      .stage-status.not-started {
        background-color: #9e9e9e;
      }
    </style>
  </head>
  <body>
    <div class="tabs-container" id="stage-tabs">
      <button class="tab" data-stage="Stage_1" onclick="selectStage('Stage_1')">Stage 1</button>
      <button class="tab" data-stage="Stage_2" onclick="selectStage('Stage_2')">Stage 2</button>
      <button class="tab" data-stage="Stage_3" onclick="selectStage('Stage_3')">Stage 3</button>
      <button class="tab" data-stage="Stage_4" onclick="selectStage('Stage_4')">Stage 4</button>
    </div>

    <div id="canvas-container"></div>

    <pre id="text-container">
        <div id="stage-info" class="stage-info"></div>
        <div id="plan"></div>
        <hr>
        <div id="exc_info"></div>
        <hr>
        <div id="exec_time"></div>
        <hr>
        <div id="exec_time_feedback"></div>
        <hr>
        <div id="metrics"></div>
        <hr>
        <div id="plot_plan"></div>
        <hr>
        <div class="plots-container" id="plots"></div>
        <hr>
        <div id="vlm_feedback"></div>
        <hr>
        <div id="datasets_successfully_tested"></div>
        <hr>
        <code id="code" class="language-python"></code>
        <hr>
        <code id="plot_code" class="language-python"></code>
    </pre>
  </body>
</html>
